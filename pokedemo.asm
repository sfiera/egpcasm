#include "gamepock.asm"

RESET		= $0000

B_WriteLCD	= $0082	;WRITES $C000->LCD DRIVERS
B_PlSnd		= $0084	;PLAYS SOUND 		(2 BYTES AFTER CALT)
B_PlMusic	= $0086	;PLAYS MUSIC CODE IN (HL)
B_RdJoy		= $0088	;READS ALL BUTTONS
B_ClS2RAM	= $008C	;Clears Screen 2 RAM
B_ClScRam	= $008E	;CLEARS SCREEN RAM
B_ClHxB		= $0094       ;Clear RAM (HL+)xB
B_HPlDE		= $0096       ;HL=HL+DE
B_HPlusMinus    = $0098	;[PC+1] HL +- byte
B_HPlE		= $009A	;HL=HL+E
B_SwapSc	= $009C       ;Swap C258+ <==> C000+
B_CpS0		= $009E       ;C000+ ==> C258+
B_CpS1		= $00A0       ;C258+ ==> C000+
B_XChgHLDE	= $00A8	;DE<->HL EXCHANGED
B_CpHDxB	= $00AA	;(HL+)->(DE+)xB
B_CmHDxB        = $00AC       ;(HL-)->(DE-)xB
B_StDotBC	= $00B0	;Set Dot @SC2; B, C = X-, Y-position
B_DrwLine	= $00B2	;DRAWS A HORIZ. LINE 	(2 BYTES AFTER CALT)
B_PtByte	= $00B4	;PRINTS BYTE AS TEXT 	(3 BYTES AFTER CALT)
B_PtText	= $00B6	;PRINTS TEXT 		(3 BYTES AFTER CALT)
B_ScrPosBC	= $00BA	;SETS HL TO SCREEN POSITION IN (B, C)
B_ScInvert	= $00CC	;INVERTS SCREEN(0) RAM
B_Sc1Invert	= $00CE	;INVERTS SCREEN(1) RAM
B_ClDotBC	= $00DA	;Clear Dot @SC2; B, C = X-, Y-position


JOYP_CURR	= $FF92		;JOYPAD CURRENT DATA
JOYB_CURR	= $FF93		;JOY BUTTON CURRENT DATA
JOYP_STROBE	= $FF94		;JOYPAD STROBE DATA
JOYB_STROBE	= $FF95		;JOY BUTTON STROBE DATA

;----------- mathvars
X_SHIFT		= 24		;HOW MUCH (NEGATIVE) IS THE GRAPH ORIGIN SHIFTED?
Y_SHIFT		= 18          ;(EG, LOWER-LEFT IS (-25, -20)
;0123456789AB
;Y=+yX^+yX^+c
;  -  2-  2-
;  .  3.  3
Y1FLAG		= $FFD0	;+/-, ( )/(0.) FOR 1ST EXPRESSION
Y2FLAG		= $FFD1	;+/-, ( )/(0.) FOR 2ND EXPRESSION
Y1PWR		= $FFD2	;1, 2, 3 POWER OF X FOR 1ST EXPRESSION
Y2PWR		= $FFD3	;1, 2, 3 POWER OF X FOR 2ND EXPRESSION
CONSTFLAG	= $FFD4	;+/- FLAG FOR CONSTANT
Y1SCALE		= $FFD5	;(1) Y-SCALE FACTOR FOR 1ST EXPRESSION
Y2SCALE		= $FFD6	;(1) Y-SCALE FACTOR FOR 2ND EXPRESSION
CONST		= $FFD7	;(1) CONSTANT IN EQUATION
RESULT		= $FFD8	;(2) OUR CURRENT TALLY/RESULT
ACC		= $FFDA	;(2) ACCUMULATOR FOR 16-BIT MULTIPLY
EXT		= $FFDC	;(2) EXTENDED RESULT FOR 16-BIT MULTIPLY
AUX		= $FFDE	;(2) 2ND WORD FOR 16-BIT MULTIPLY
;----------- mathvars

VB_PASS		= $FFE0            ;A FLAG FOR STABLE TIMER WRITING
VB_COUNT 	= $FFE1            ;HOW MANY "MAIN LOOPS" HAVE PASSED
VB2_COUNT 	= $FFE2            ;DELTA BETWEEN "MAIN LOOPS" AND "INTERRUPTS"
RLEMARKER	= $FFE3	;MARKER FOR RLE LOOP COUNT
RLESTOP		= $FFE4	;MARKER FOR END OF DATA
TST_MODE	= $FFE5	;THE MODE THE DEMO IS CURRENTLY IN:
		    		;0 = TITLE SCREEN
		    		;1 = MAIN MENU
		    		;2 = MEMORY VIEWER
		    		;3 = CODE EXECUTOR
		    		;4 = MUSIC PLAYER
		    		;5 = PICTURE 1
		    		;6 = PIC DISPLAY
		    		;7 = CODE EXECUTOR & REGISTER DUMP
		    		;8 = "GAME" TITLE SCREEN
		    		;9 = "GAME" IN-GAME SCROLLER
		    		;A = GRAPHER
		    		;B = MINI-NOTEPAD EDITOR
		    		;C = BIG SCROLLTEXT FROM NOTEPAD
		    		;...
PLAYING		= $FFE6	;IS THE EXECUTOR/MUSIC/PICTURE PLAYING (BUSY)?
CURSX		= $FFE7	;CURSOR POSITION X
CURSY		= $FFE8	;CURSOR POSITION Y
SCRLCOUNT	= $FFE9	;SCROLLER COUNTER (5->0)
SINCNT		= $FFEA	;SINE POSITION COUNTER (0-0F)
LOOPCNT		= $FFEB	;A LOOP COUNTER FOR ANY PURPOSE
COLUMN		= $FFEC	;ADDRESS (0) OR DATA (1) COLUMN
CURADD		= $FFED	;THE CURRENT ADDRESS IN THE EDITOR (2 BYTES)
INST1		= $FFEF	;OUR INSTRUCTION FOR DECODING
INST4		= $FFF0	;OPERAND 3?

TXTRAM		= $C708	;STORAGE FOR THE TEXT POINTER (2 BYTES)
TXTBUF		= $C70A	;STORAGE FOR 1 CHARACTER
SIN1POS		= $C70B	;STORAGE FOR SINE TABLE (2 BYTES)
HEXADD		= $C710	;HEX EDITOR INIT POINTER (2 BYTES)
PRGADD		= $C712	;PROGRAM EDITOR INIT POINTER (2 BYTES)
MUSADD		= $C714	;MUSIC EDITOR INIT POINTER (2 BYTES)
ADDRT1		= $C716	;A TEMP STORAGE 1 (2 BYTES)
ADDRT2		= $C718	;A TEMP STORAGE 2 (2 BYTES)
FACING		= $C71A	;CURRENT DIRECTION WE FACE
FACOLD		= $C71B	;PREVIOUS DIRECTION...
INSTEXT		= $C71C	;13 BYTES FOR OUR TEXT WRITING...
ANOTHERVAR	= $C729
NOTERAM		= $C72F	;C72F-C78F (OUR NOTEPAD RAM STORAGE)

;------------------------------
HEXDEF		= $FF80	;DEFAULT ADDRESS FOR HEX EDITOR
PRGDEF		= $C500	;DEFAULT ADDRESS FOR PROGRAM EDITOR
MUSDEF		= $C600	;DEFAULT ADDRESS FOR MUSIC DATA
SPRDEST		= $C1E2	;THE DESTINATION FOR THE BOTTOM HALF OF THE SPRITE

#bankdef rom
{
    addr = $4000
    size = $4000
    fill = true
    outp = 0
}

;--------------------------------------------------------
	DB	$55		;Pokekon Identifier
	DW	START, START     ;RESET Addresses
	DW	MYFONT - $8C		;FONT Address
	DW	$0000		;CALT 00D6 data
IntT:	JMP 	INTERRUPT
Int0:    JMP 	RESET
Int1:    JMP 	RESET
;--------------------------------------------------------
;--------------------------------------------------------
START:
	 DI
	 LXI	SP, $C800 	;SET UP THE STACK POINTER

	 CALL	SETVARS		;INIT ALL OUR VARIABLES
	 CALL	MODE0SETUP      ;;;;;START WITH MAIN SCREEN
	 CALL	TIMER_START

HERE:
      CALL	JOY_ROUTINE	;DO JOYSTICK LOGIC
      CALL	DEMO_LOGIC	;DO DEMO FUNCTIONS/LOGIC
      INRW      [VB_COUNT]
      NOP		;REQUIRED FOR THE ABOVE
;      MVI	A, 00
;      STAW	[VB2_COUNT]
      JR	HERE
;==============================================
;==============================================






MODE0ROUTINE:            ;MAIN LOOP FOR TITLE SCREEN
            ONIW	[JOYB_STROBE], $3F	;ARE ANY BUTTONS PRESSED?
            JR		M0_NOBUT		;IF NOT, DO NOTHING
            CALL	MODE1SETUP
	    JR		MD0END
M0_NOBUT:
	    ONIW	[PLAYING], $01		;IS IT FADING IN?
	    JR		M0_SCROLL               ;IF NOT, SCROLL
	    CALL	FADEPIC			;"FADE IN" THE PICTURE
            OFFIW	[JOYP_CURR], $01		;IS "UP" PRESSED?
            JR		MO_BOBO			;IF SO, PAUSE THE SWEEP
            ONIW	[JOYP_CURR], $02		;IS "LEFT" PRESSED?
            JR		MD0END			;IF SO, SWEEP BACKWARDS
	    DCRW        [LOOPCNT]			;DECREMENT THE CURSOR...
MO_BOBO:
	    DCRW        [LOOPCNT]			;DECREMENT THE CURSOR...
            JR          MD0END
            MVI		A, 00
            STAW	[LOOPCNT]
	    JR          MD0END
M0_SCROLL:
	    CALL	TXSCROLL

MD0END:
      	    CALT	B_WriteLCD
	    RET
;==============================================
;==============================================
MODE1ROUTINE:            ;MAIN LOOP FOR MAIN MENU
	    ONIW	[JOYP_STROBE], $01		;IS "UP" PRESSED?
            JR		M1_NOUP			;IF NOT, CHECK NEXT
	    CALL        CLMENCURS  		;CLEAR MENU CURSOR GFX
	    DCRW        [CURSY]			;DECREMENT THE CURSOR...
	    JR		M1CRSUP			;JUMP IF OK (NO BORROW)
	    MVI	A, 07                            ;OTHERWISE, RESET CURSY
    	    STAW	[CURSY]
M1CRSUP:	    CALL	DRMENCURS
	    JMP		M1_END
;-----
M1_NOUP:     ONIW	[JOYP_STROBE], $04		;IS "DOWN" PRESSED?
            JR		M1_NODWN		;IF NOT, DO NOTHING
	    CALL        CLMENCURS  		;CLEAR MENU CURSOR GFX
	    INRW        [CURSY]			;INCREMENT THE CURSOR...
;	    NOP
	    EQIW	[CURSY], 08		;IS THE CURSOR TOO HIGH?
	    JR		M1CRSDN
	    MVI	A, 00                            ;OTHERWISE, RESET CURSY
    	    STAW	[CURSY]
M1CRSDN:	    CALL	DRMENCURS
	    JR		M1_END
;-----
M1_NODWN:
            ONIW	[JOYB_STROBE], $3E	;IS ANY BUTTON PRESSED?
            JR		M1NOSTART		;IF NOT, CHECK NEXT
            JMP		TODEMSETUP		;JUMP TO THE "DEMO SETUP TABLE"
M1NOSTART:
M1_END:
      	    CALT	B_WriteLCD
      	    RET
;==============================================
;==============================================
MODE2ROUTINE:            ;THE MEMORY EDITOR!
            ONIW	[JOYB_STROBE], $01		;IS "SELECT" PRESSED?
            JR		M2NOSELECT		;IF NOT, CHECK NEXT
            MVI		A, 00
	    STAW	[CURSY]
	    MVI		A, 01		;SET TO DATA COLUMN
	    STAW	[COLUMN]
       	    LHLD	[CURADD]		;COPY CURRENT ADDRESS BACK TO HEX EDITOR ADDRESS
	    SHLD     [HEXADD]

            JMP         MODE1SETUP
M2NOSELECT:
            ONIW	[JOYB_STROBE], $08		;IS "START" PRESSED?
            JMP		HEXPAD		;IF NOT, CHECK GENERAL HEX EDITOR INPUTS
        ;DISPLAY CURRENT DATA AS GRAPHICS!
       		LHLD	[CURADD]		;COPY CURRENT ADDRESS BACK TO HEX EDITOR ADDRESS
		SHLD     [HEXADD]
        	MVI	A, 06		;THAT'S IT?
	    	STAW	[TST_MODE]
	    RET
;==============================================
;==============================================
MODE3ROUTINE:            ;THE CODE EDITOR
            ONIW	[JOYB_STROBE], $01		;IS "SELECT" PRESSED?
            JR		M3NOSELECT		;IF NOT, CHECK NEXT
            MVI		A, 01
	    STAW	[CURSY]
;	    MVI		A, 01		;SET TO DATA COLUMN
	    STAW	[COLUMN]
       	    LHLD	[CURADD]		;COPY CURRENT ADDRESS BACK TO PRG EDITOR ADDRESS
	    SHLD     	[PRGADD]
            JMP         MODE1SETUP
M3NOSELECT:
            ONIW	[JOYB_STROBE], $08		;IS "START" PRESSED?
            JMP		HEXPAD		;IF NOT, CHECK GENERAL HEX EDITOR INPUTS
        ;RUN THE PROGRAM AT THE CURSOR!
       		LHLD	[CURADD]		;COPY CURRENT ADDRESS BACK TO PRG EDITOR ADDRESS
		SHLD     [PRGADD]
        	MVI	A, 07		;THAT'S IT?
	    	STAW	[TST_MODE]
	    	CALL	EXEC_CODE	;EXECUTE THE CODE
	    	CALL	M3RESULTS	;PRINT REGISTER CONTENTS
	    	CALT	B_PlSnd		;PLAY A BEEP TO SHOW WE'RE ALIVE
	    	DB	02, 08		;SOUND DATA
	    RET
;==============================================
;==============================================
MODE4ROUTINE:            ;THE MUSIC PLAYER
            ONIW	[JOYB_STROBE], $01		;IS "SELECT" PRESSED?
            JR		M4NOSELECT		;IF NOT, CHECK NEXT

           MVI		A, 02
	    STAW	[CURSY]
	    MVI		A, 01		;SET TO DATA COLUMN
	    STAW	[COLUMN]
       	    LHLD	[CURADD]		;COPY CURRENT ADDRESS BACK TO MUSIC EDITOR ADDRESS
	    SHLD     	[MUSADD]
;---
	    LXI		HL, MUS_OFF			;TURN OFF MUSIC!
	    CALT    	B_PlMusic
;---
            JMP         MODE1SETUP
M4NOSELECT:
            ONIW	[JOYB_STROBE], $08		;IS "START" PRESSED?
            JMP		HEXPAD		;IF NOT, CHECK GENERAL HEX EDITOR INPUTS
		CALL	MUS_PLAY
	    RET
;==============================================
;==============================================
MODE5ROUTINE:            ;ALTERNATE BETWEEN 2 PICTURES
            ONIW	[JOYB_STROBE], $01		;IS "SELECT" PRESSED?
            JR		M5NOSELECT		;IF NOT, CHECK NEXT
;            MVI	        A, 03                   ;OTHERWISE, RESET CURSY
;    	    STAW	[CURSY]
            JMP         MODE1SETUP
M5NOSELECT:
	;FLICKER THE IMAGE!
	  CALT	B_WriteLCD    		;1ST SCREEN TO LCD
	  CALL  LCD2_RAM_WRITE          ;2ND SCREEN TO LCD
	EQIW	[VB_PASS], 32		;HAS THE TIMER COUNTED UP?
	    RET                         ;IF NOT, JUST RETURN
	    ANIW	[VB_PASS], 00	;CLEAR VBPASS.

	    MVI		C, 07		;A LOOP COUNTER
SLIDLOOP:
	    PUSH	BC
	    CALL	SLIDE1
	    CALT	B_WriteLCD    	;1ST SCREEN TO LCD
	    CALL	SLIDE2
	    CALL  	LCD2_RAM_WRITE  ;2ND SCREEN TO LCD
	    POP		BC
	    DCR		C
	    JR		SLIDLOOP        ;SLIDE THE GRAPHICS 8 TIMES...

	    INRW	[INST4]		;INC OUR PIC COUNTER
	    ANIW	[INST4], $03	;LIMIT IT TO 0..4
	    CALL	NEXTPIC
	    
	    RET
;==============================================
;==============================================
MODE6ROUTINE:            ;THE GRAPHIC VIEWER (SUBROUTINE)
            ONIW	[JOYB_STROBE], $01		;IS "SELECT" PRESSED?
            JR		M6NOSELECT		;IF NOT, CHECK NEXT
            JMP         DEM1SETUP		;GO BACK TO *HEX* EDITOR!!
M6NOSELECT:
	;UPDATE THE IMAGE!
          LXI     DE, $C000		;OUR DESTINATION ADDRESS
          LHLD	[CURADD]			;OUR SOURCE ADDRESS
          CALL	$0984			;COPY SOURCE->DEST!
	  CALT	B_WriteLCD    		;1ST SCREEN TO LCD
	    RET
;==============================================
;==============================================
MODE7ROUTINE:            ;THE PROGRAM EXECUTOR (SUBROUTINE)
            ONIW	[JOYB_STROBE], $01		;IS "SELECT" PRESSED?
            JR		M7NOSELECT		;IF NOT, CHECK NEXT
            JMP         DEM2SETUP		;GO BACK TO *PRG* EDITOR!!
M7NOSELECT:
            ONIW	[JOYB_STROBE], $3E		;ARE OTHER BUTTONS PRESSED?
            JR		M7NOBUTS		;IF NOT, CHECK NEXT
            CALT        B_SwapSc		;EXCHANGE THE SCREENS
            CALT        B_WriteLCD    		;1ST SCREEN TO LCD
M7NOBUTS:
	    RET
;==============================================
;==============================================
MODE8ROUTINE:            ;THE MARIO TITLE SCREEN
            ONIW	[JOYB_STROBE], $01		;IS "SELECT" PRESSED?
            JR		M8NOSELECT		;IF NOT, CHECK NEXT
            MVI	        A, 04                   ;OTHERWISE, RESET CURSY
    	    STAW	[CURSY]
            JMP         MODE1SETUP
M8NOSELECT:
            ONIW	[JOYB_STROBE], $08		;IS "START" PRESSED?
            JR		M8NOSTART		;IF NOT, CHECK NEXT
	    ;SO NOW [WE] JUST GO TO MODE 9 (INGAME) DIRECTLY!

	  	CALT	B_ClScRam       ;CLEAR THE SCREEN!
	  	CALT	B_WriteLCD

		LXI	HL, MARLEV        ;RUN-LENGTH ENCODED MARIO GFX
		LXI     DE, $C000	;START OF SCREEN 1
		CALL	RLE_DECODE	;WRITE RLE DATA
		
		CALL	SPR_DRAW	;XOR IN OUR SPRITE

	  	CALT	B_WriteLCD
            	LXI	HL, MARIO_MUSIC 	;PLAY A SHORT TUNE.
		CALT    B_PlMusic
 	  	MVI	A, 09     	;MARIO INGAME
	  	STAW	[TST_MODE]
	  	MVI	A, 00
	  	STAW	[SCRLCOUNT]       ;RESET THE SCROLL VALUE (00-75)
	  	RET
M8NOSTART:
	;FLICKER THE IMAGE!
	  CALT	B_WriteLCD    		;1ST SCREEN TO LCD
	  CALL  LCD2_RAM_WRITE          ;2ND SCREEN TO LCD
	    RET
;==============================================
;==============================================
MODE9ROUTINE:            ;CONTROL MARIO INGAME!... (SUBROUTINE)

            ONIW	[JOYB_STROBE], $01		;IS "SELECT" PRESSED?
            JR		M9NOSELECT		;IF NOT, CHECK NEXT
            MVI	        A, 04
    	    STAW	[CURSY]
            JMP         MODE1SETUP              ;RETURN TO MAIN MENU
M9NOSELECT:
            ONIW	[JOYP_CURR], $02		;IS "LEFT" PRESSED?
            JR		M9NOLEFT		;IF SO, SCROLL BACKWARDS, IF NOT, CHECK NEXT
	    DCRW        [SCRLCOUNT]		;DECREMENT THE SCROLL...
	    JR		SCRLEFT                 ;IF A-O-K, SCROLL IT
            MVI		A, 00                    ;IF NOT, DON'T DO A THING!
            STAW	[SCRLCOUNT]
            MVI		A, 01			;FACE TO THE LEFT (STAND STILL)
	    JRE          MD9WRT
	;------
SCRLEFT:	    MOV		A, [FACING]                ;GET THE SPRITE DIRECTION, ETC
	    ANI		A, 02			;0SRF F=flip, R=run motion, S=stand/run
	    					;ISOLATE ONLY RUNNING FRAME
	    XRI		A, 07			;SWITCH RUNNING POSE & FACE LEFT TOO!
	    MOV		[FACING], A
	    CALL	SPR_CLEAR		;CLEAR OUR SPRITE
	    JMP		SCRO_L			;SCROLL OUR SCREEN LEFT
M9NOLEFT:
            ONIW	[JOYP_CURR], $08		;IS "RIGHT" PRESSED?
            JR		M9NORIGHT		;IF SO, SCROLL FORWARDS, IF NOT, CHECK NEXT
	    INRW        [SCRLCOUNT]		;DECREMENT THE SCROLL...
	    EQIW        [SCRLCOUNT], 76		;IS IT TOO HIGH?
	    JR		SCRRIGHT                ;IF A-O-K, SCROLL IT
            MVI		A, 75                    ;IF NOT, DON'T DO A THING!
            STAW	[SCRLCOUNT]
            MVI		A, 00                    ;FACE TO THE RIGHT (STAND STILL)
	    JR          MD9WRT
	;------
SCRRIGHT:    MOV		A, [FACING]                ;GET THE SPRITE DIRECTION, ETC
	    ANI		A, 02			;0SRF F=flip, R=run motion, S=stand/run
	    					;ISOLATE ONLY RUNNING FRAME
	    XRI		A, 06			;SWITCH RUNNING POSE & FACE RIGHT!
	    MOV		[FACING], A
	    CALL	SPR_CLEAR		;CLEAR OUR SPRITE
	    JMP		SCRO_R			;SCROLL OUR SCREEN RIGHT

M9NORIGHT:
	    MOV		A, [FACING]                ;GET THE SPRITE DIRECTION, ETC
	    ANI		A, 01			;STAND STILL (EITHER LEFT OR RIGHT...)
MD9WRT:
	    MOV		[FACING], A
	    CALL	SPR_CLEAR		;CLEAR OUR SPRITE
	    CALL	SPR_DRAW                ;DRAW OUR NEXT SPRITE
   	    CALT	B_WriteLCD
MD9END:
	    RET
;==============================================
;==============================================
GPH_REDRAW:
	CALT	B_ClS2RAM
	ANIW	[PLAYING], 0  	;THIS WILL BE OUR X-COORDINATE
	ORIW	[COLUMN], $FF	;"INTERPOLATION" START VALUE (INVALID)
	CALL	AXES_DRAW       ;DRAW THE AXES ON-SCREEN
	CALL	FORMULA_DRAW	;DRAW THE Y=.... FORMULA
	RET

AXES_DRAW:                       ;DRAW THE AXES ON-SCREEN
	    MVI		A, Y_SHIFT             ;Y-POS
	    MOV		C, A
	    MVI		A, 63            ;FLIP THE Y-AXIS
	    SUB		A, C
	    MOV		C, A
	    MVI		B, 0
	    CALT        B_StDotBC	;DRAW THE DOT
	    PUSH	HL
	    POP		DE
	    INX		DE
	    INX		DE		;POINT 2 BYTES AHEAD
	    MVI		B, $24
AXLP1:       LDAX	[HL+]
	    STAX	[DE+]
	    INX		HL
	    INX		DE
	    DCR		B
	    JR          AXLP1

	    MVI		L, X_SHIFT+$58		;X-POS + SCREEN2 RAM OFFSET
	    MVI		H, $C2
	    MVI		B, 06	;7 LOOPS
AXLP2:	    MVI		A, $AA	;A DITHER-PATTERN
	    STAX	[HL]
	    CALT        B_HPlusMinus
	    DB 75	;ADD 75 BYTES TO HL!
	    DCR		B
	    JR		AXLP2
	RET

FORMULA_DRAW:	;DRAWS THE "FORMULA" (Y=+yX^+yX^+c) ON-SCREEN

	LXI	HL, FRMTX1	;POINT TO 1ST TEXT AT BOTTOM
	CALT	B_PtText
	DB	0, 57, $12	;LOWER-LEFT, 2 CHARACTERS.
	MVI	A, 0
	LXI	HL, $C46D		;CLEAR 3 LINES (A BAD HACK!)
	STAX	[HL+]
	STAX	[HL+]
	STAX	[HL]

	LXI	HL, FRMTX3	;POINT TO +/- CHAR
	ONIW    [Y1FLAG], 2	;+ OR -?
	JR	FRMNP1
	INX	HL		;POINT TO NEGATIVE
;FRMNP1
	CALT	B_PtText
	DB	9, 57, $01	;LOWER-LEFT, 1 CHARACTER.
FRMNP1:
	ONIW	[Y1FLAG], 1	;IS IT REGULAR OR 0.XXX?
	JR	FRMNP2
	LXI	HL, $C472
	MVI	A, $C0		;A "PERIOD" GRAPHIC
	ORAX	[HL]
	STAX	[HL+]		;WRITE IT TWICE
        MVI	A, $C0
	STAX	[HL]
FRMNP2:
	LXI	HL, Y1SCALE		;POINT TO 1ST NUMBER
        CALT	B_PtByte
        DB	16, 57, $00	;5x7 CHARACTER, RIGHT NYBBLE
	LXI	HL, FRMTX2	;POINT TO 'X' TEXT
	CALT	B_PtText
	DB	22, 57, $01	;LOWER-LEFT, 1 CHARACTER.

	LXI	HL, FRMTX4	;POINT TO EXPONENT TEXT
	LDAW	[Y1PWR]
	ADD	A, L
	MOV	L, A		;ADD OUR POINTER (QUICKLY!)
	CALT	B_PtText
	DB	27, 57, $01	;LOWER-LEFT, 1 CHARACTER.
;-------------------------- +9X^
	LXI	HL, FRMTX3	;POINT TO +/- CHAR
	ONIW    [Y2FLAG], 2	;+ OR -?
	JR	FRMNP3
	INX	HL		;POINT TO NEGATIVE
FRMNP3:  CALT	B_PtText
	DB	33, 57, $01	;LOWER-LEFT, 1 CHARACTER.

	ONIW	[Y2FLAG], 1	;IS IT REGULAR OR 0.XXX?
	JR	FRMNP4
	LXI	HL, $C48A
	MVI	A, $C0		;A "PERIOD" GRAPHIC
	ORAX	[HL]
	STAX	[HL+]		;WRITE IT TWICE
        MVI	A, $C0
	STAX	[HL]
FRMNP4:
	LXI	HL, Y2SCALE		;POINT TO 2ND NUMBER
        CALT	B_PtByte
        DB	40, 57, $00	;5x7 CHARACTER, RIGHT NYBBLE
	LXI	HL, FRMTX2	;POINT TO 'X' TEXT
	CALT	B_PtText
	DB	46, 57, $01	;LOWER-LEFT, 1 CHARACTER.

	LXI	HL, FRMTX4	;POINT TO EXPONENT TEXT
	LDAW	[Y2PWR]
	ADD	A, L
	MOV	L, A		;ADD OUR POINTER (QUICKLY!)
	CALT	B_PtText
	DB	51, 57, $01	;LOWER-LEFT, 1 CHARACTER.
;-------------------------- +CC
	LXI	HL, FRMTX3	;POINT TO +/- CHAR
	ONIW    [CONSTFLAG], 1	;+ OR -?
	JR	FRMNP5
	INX	HL		;POINT TO NEGATIVE
FRMNP5:  CALT	B_PtText
	DB	57, 57, $01	;LOWER-LEFT, 1 CHARACTER.
	LXI	HL, CONST		;POINT TO CONSTANT
        CALT	B_PtByte
        DB	63, 57, $19	;5x7 CHARACTER, LEFT, RIGHT NYBBLE
	RET
FRMTX1:	DB	"Y"-$20, "="-$20
FRMTX2:	DB	"X"-$20
FRMTX3:	DB      "+"-$20, "-"-$20
FRMTX4:	DB	0, "2"+$10, "3"+$10, "4"+$10
;======================================================================================
;======================================================================================


FUNCTION:		;EVALUATES OUR FUNCTION...
;Y1FLAG, Y2FLAG, Y1PWR, Y2PWR, CONSTFLAG, Y1SCALE, Y2SCALE, CONST, RESULT, ACC, AUX, EXT

	MVI	A, 00
	STAW	[RESULT]
	STAW	[RESULT+1]
	STAW	[CURADD]  	;TEMPORARY STORAGE FOR THE 1ST COMPUTED VALUE
	STAW	[CURADD+1]

	NEIW	[Y1SCALE], 0         ;IS OUR FIRST VALUE MULTIPLIED BY ZERO?
	JRE	FCN1XVAL	  ;IF SO, EVALUATE NOTHING!

;------------------------------- SHIFT X TO START AT -25 (OR WHATEVER)
	LDAW	[PLAYING]
	SUI	A, X_SHIFT
	STAW	[RESULT]
	ONIW	[RESULT], $80	;IS IT NEGATIVE?
	MVI	A, 0
	MVI	A, $FF
	STAW	[RESULT+1]

	NEIW	[Y1PWR], 0		;IS OUR FIRST POWER ^2, 3, OR 4?
	JRE	FCN1PWR

;-------------------------------------  MULTIPLY X*X(*X*X)
	    LDAW	[Y1PWR]
	    DCR		A
	    NOP
	    STAW	[LOOPCNT]		;A TEMP VARIABLE!
	    LDAW	[RESULT]
	    STAW	[ACC]
	    LDAW	[RESULT+1]
	    STAW	[ACC+1]
FC1PWLOOP:
	    LDAW	[RESULT]          ;RELOAD OUR REGISTER
	    STAW	[AUX]
	    LDAW	[RESULT+1]
	    STAW	[AUX+1]
	    CALL	MULT16		;MULTIPLY 2 NUMBERS!
	    DCRW	[LOOPCNT]
	    JR		FC1PWLOOP
	    LDAW	[ACC]
	    STAW	[RESULT]
	    LDAW	[ACC+1]
	    STAW	[RESULT+1]
	    
;---------------------------------------- SCALE OUR RESULTS BY Y-SCALE!
FCN1PWR:
	OFFIW	[Y1FLAG], 1        ;IF THE FLAG IS 0, DO REGULAR MULTIPLICATION
	JR	FC1DIV          ;IF 1, DIVIDE SCALE BY 100!
	LDAW	[Y1SCALE]
	STAW	[AUX+1]   	;MULTIPLY BY SCALE
	MVI	A, 0
	STAW	[AUX]
	JR	FC1POS
FC1DIV:
	LDAW	[Y1SCALE]
	MOV	E, A
	LXI	HL, YSCTABLE      ;SCALE BY A FRACTION BY USING A LOOKUP-TABLE.
	CALT    B_HPlE
	LDAX	[HL]
	STAW	[AUX]		;1/256TH THE SIZE!
	MVI	A, 0
	STAW	[AUX+1]
;----------------------------
FC1POS:	LDAW	[RESULT]
	STAW	[ACC]
	LDAW	[RESULT+1]
	STAW	[ACC+1]

	CALL	MULT16         	;NOW MULTIPLY X BY SCALE
	LDAW	[ACC+1]
	STAW	[RESULT]
 	LDAW	[EXT]
	ONIW	[Y1FLAG], 1        ;IF USING A FRACTION, COPY THE SIGN OVER!
	JR	FC1USSIGN
	OFFIW	[RESULT], $80	;IS THE HIGH BIT SET?
	MVI	A, $FF
FC1USSIGN: STAW	[RESULT+1]
;--------------------------------------------- FLIP SIGN IF NECESSARY!
	ONIW	[Y1FLAG], 2	;IS IT POSITIVE OR NEGATIVE?
	JR	FC1NFLIP

	LDAW	[RESULT+1]        ;XOR HIGH BYTE FIRST, JUST FOR FUN...
	XRI	A, $FF
	STAW	[RESULT+1]
	LDAW	[RESULT]
	XRI	A, $FF
	STAW	[RESULT]
	INRW	[RESULT]		;IF A CARRY, SKIP!
	JR	FC1FLHI
	INRW	[RESULT+1]	;INC?
	NOP
FC1FLHI:
FC1NFLIP:
	LDAW	[RESULT]
	STAW	[CURADD]
	LDAW	[RESULT+1]
	STAW	[CURADD+1]	;STORE IT TEMPORARILY
	ANIW	[RESULT], 0	;CLEAR 1ST RESULT
	ANIW	[RESULT+1], 0
FCN1XVAL:

;====================================== COMPUTE THE 2ND VALUE FOR THE GRAPH! ==========
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

	NEIW	[Y2SCALE], 0         ;IS OUR SECOND VALUE MULTIPLIED BY ZERO?
	JRE	FCN2XVAL	  ;IF SO, EVALUATE NOTHING!

;------------------------------- SHIFT X TO START AT -25 (OR WHATEVER)
	LDAW	[PLAYING]
	SUI	A, X_SHIFT
	STAW	[RESULT]
	ONIW	[RESULT], $80	;IS IT NEGATIVE?
	MVI	A, 0
	MVI	A, $FF
	STAW	[RESULT+1]

	NEIW	[Y2PWR], 0		;IS OUR SECOND POWER ^2, 3, OR 4?
	JRE	FCN2PWR

;-------------------------------------  MULTIPLY X*X(*X*X)
	    LDAW	[Y2PWR]
	    DCR		A
	    NOP
	    STAW	[LOOPCNT]		;A TEMP VARIABLE!
	    LDAW	[RESULT]
	    STAW	[ACC]
	    LDAW	[RESULT+1]
	    STAW	[ACC+1]
FC2PWLOOP:
	    LDAW	[RESULT]          ;RELOAD OUR REGISTER
	    STAW	[AUX]
	    LDAW	[RESULT+1]
	    STAW	[AUX+1]
	    CALL	MULT16		;MULTIPLY 2 NUMBERS!
	    DCRW	[LOOPCNT]
	    JR		FC2PWLOOP
	    LDAW	[ACC]
	    STAW	[RESULT]
	    LDAW	[ACC+1]
	    STAW	[RESULT+1]

;---------------------------------------- SCALE OUR RESULTS BY Y-SCALE!
FCN2PWR:
	OFFIW	[Y2FLAG], 1        ;IF THE FLAG IS 0, DO REGULAR MULTIPLICATION
	JR	FC2DIV          ;IF 1, DIVIDE SCALE BY 100!
	LDAW	[Y2SCALE]
	STAW	[AUX+1]   	;MULTIPLY BY SCALE
	MVI	A, 0
	STAW	[AUX]
	JR	FC2POS
FC2DIV:
	LDAW	[Y2SCALE]
	MOV	E, A
	LXI	HL, YSCTABLE      ;SCALE BY A FRACTION BY USING A LOOKUP-TABLE.
	CALT    B_HPlE
	LDAX	[HL]
	STAW	[AUX]		;1/256TH THE SIZE!
	MVI	A, 0
	STAW	[AUX+1]
;----------------------------
FC2POS:	LDAW	[RESULT]
	STAW	[ACC]
	LDAW	[RESULT+1]
	STAW	[ACC+1]

	CALL	MULT16         	;NOW MULTIPLY X BY SCALE
	LDAW	[ACC+1]
	STAW	[RESULT]
 	LDAW	[EXT]
	ONIW	[Y2FLAG], 1        ;IF USING A FRACTION, COPY THE SIGN OVER!
	JR	FC2USSIGN
	OFFIW	[RESULT], $80	;IS THE HIGH BIT SET?
	MVI	A, $FF
FC2USSIGN: STAW	[RESULT+1]
;--------------------------------------------- FLIP SIGN IF NECESSARY!
	ONIW	[Y2FLAG], 2	;IS IT POSITIVE OR NEGATIVE?
	JR	FC2NFLIP

	LDAW	[RESULT+1]        ;XOR HIGH BYTE FIRST, JUST FOR FUN...
	XRI	A, $FF
	STAW	[RESULT+1]
	LDAW	[RESULT]
	XRI	A, $FF
	STAW	[RESULT]
	INRW	[RESULT]		;IF A CARRY, SKIP!
	JR	FC2FLHI
	INRW	[RESULT+1]	;INC?
	NOP
FC2FLHI:
FC2NFLIP:
FCN2XVAL:
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	LDAW	[RESULT]          ;ADD SOMETHING (OR NOTHING?)
	MOV	L, A
	LDAW	[CURADD]          ;OUR FIRST EVALUATION'S RESULT
	ADD	A, L
	STAW	[RESULT]
	LDAW	[RESULT+1]
	MOV	L, A
	LDAW	[CURADD+1]
	ADC	A, L
	STAW	[RESULT+1]

;--------------------------------------------- ADD OUR CONSTANT

	NEIW	[CONST], 0		;IS OUR CONSTANT ZERO?
	JR	FCNOCONST
	LDAW	[CONST]
	CALL	BCD2HEX		;CONVERT BACK TO HEXADECIMAL
	MOV	L, A
	LDAW	[RESULT]
	OFFIW	[CONSTFLAG], 1	;IS IT NEGATIVE?
	JR	SBCONST
	ADD	A, L		;ADD OUR RESULT+CONSTANT
	STAW	[RESULT]
	LDAW	[RESULT+1]        ;ADD CARRY TO HIGH BYTE
	ACI	A, 0
	JR	ASCONST
SBCONST: SUB	A, L		;SUB OUR RESULT-CONSTANT
	STAW	[RESULT]
	LDAW	[RESULT+1]        ;SUB BORROW FROM HIGH BYTE
	SBI	A, 0
ASCONST:
	STAW	[RESULT+1]
FCNOCONST:
	RET

BCD2HEX: 	;DESTROYS REGISTERS WILLY-NILLY
	MOV	H, A     ;STORE ORIGINAL
	ANI	A, $0F	;ISOLATE LOW NYB
	MOV	L, A     ;STORE LOW NYB IN L
	MOV	A, H     ;GET FULL VALUE BACK
	ANI	A, $F0	;GET HIGH NYB
	CLC
	RAR             ;NYB * 8
	MOV	H, A	;STORE NYB*8 IN H
	RAR
	RAR		;NYB * 2
	ADD	A, H	;NYB *10
	ADD	A, L	;NYB IN HEX!
	RET
;======================================================================================
YSCTABLE: DB 0, 1, 3, 5, 9, 13, 23, 64, 128, 201
;======================================================================================
MODEAROUTINE:            ;DRAW CURVES AS FAST AS POSSIBLE
            ONIW	[JOYB_STROBE], $01		;IS "SELECT" PRESSED?
            JR		MANOSELECT		;IF NOT, CHECK NEXT
            MVI	        A, 05                   ;OTHERWISE, RESET CURSY
    	    STAW	[CURSY]
            JMP         MODE1SETUP
MANOSELECT:
	    ONIW        [JOYB_STROBE], $02		;IS "1" PRESSED? (+-. FLAGS 1)
            JR		MANOB1			;IF NOT, CHECK NEXT
	    INRW	[Y1FLAG]
	    ANIW	[Y1FLAG], 3		;LIMIT IT!
MAREDRW:     JMP		GPH_REDRAW
MANOB1:
	    ONIW        [JOYB_STROBE], $04		;IS "3" PRESSED? (INC SCALE VALUE 1)
            JR		MANOB3			;IF NOT, CHECK NEXT
	    LDAW	[Y1SCALE]
	    INR		A                       ;INCREASE IT,
	    DAA
	    ANI		A, $0F			;BUT LIMIT TO DECIMAL!
	    STAW	[Y1SCALE]
	    JR          MAREDRW
MANOB3:
	    ONIW        [JOYP_STROBE], $02		;IS "L" PRESSED? (INC EXPONENT 1)
            JR		MANOLF			;IF NOT, CHECK NEXT
	    INRW	[Y1PWR]
	    ANIW	[Y1PWR], 3		;LIMIT IT!
	    JRE		MAREDRW
MANOLF:
	    ONIW        [JOYB_STROBE], $10		;IS "2" PRESSED? (+-. FLAGS 2)
            JR		MANOB2			;IF NOT, CHECK NEXT
	    INRW	[Y2FLAG]
	    ANIW	[Y2FLAG], 3		;LIMIT IT!
	    JRE		MAREDRW
MANOB2:
	    ONIW        [JOYB_STROBE], $20		;IS "4" PRESSED? (INC SCALE VALUE 2)
            JR		MANOB4			;IF NOT, CHECK NEXT
	    LDAW	[Y2SCALE]
	    INR		A                       ;INCREASE IT,
	    DAA
	    ANI		A, $0F			;BUT LIMIT TO DECIMAL!
	    STAW	[Y2SCALE]
	    JRE         MAREDRW
MANOB4:
	    ONIW        [JOYP_STROBE], $08		;IS "R" PRESSED? (INC EXPONENT 2)
            JR		MANORT			;IF NOT, CHECK NEXT
	    INRW	[Y2PWR]
	    ANIW	[Y2PWR], 3		;LIMIT IT!
	    JRE		MAREDRW
MANORT:
	    ONIW        [JOYP_STROBE], $01		;IS "U" PRESSED? (INC CONSTANT HNYB)
            JR		MANOUP			;IF NOT, CHECK NEXT
	    LDAW	[CONST]
	    ADI		A, $10			;ADD 10 DECIMAL
	    LTI		A, $9A			;IS IT OVERFLOWING?
	    ANI		A, $0F			;CLEAR HIGH NYB
	    STAW	[CONST]
	    JRE		MAREDRW
MANOUP:
	    ONIW        [JOYP_STROBE], $04		;IS "D" PRESSED? (INC CONSTANT LNYB)
            JR		MANODN			;IF NOT, CHECK NEXT
	    LDAW	[CONST]
	    INR		A
	    DAA					;ADD 1 DECIMAL
	    STAW	[CONST]
	    JRE		MAREDRW
MANODN:
	    ONIW        [JOYB_STROBE], $08		;IS "STA" PRESSED? (+- CONST FLAGS)
            JR		MANOST			;IF NOT, CHECK NEXT
	    INRW	[CONSTFLAG]
	    ANIW	[CONSTFLAG], 1		;LIMIT IT!
	    JRE		MAREDRW
MANOST:
;==============================
; THE BULK OF OUR GRAPH-DRAWING CODE STARTS HERE!
	    NEIW	[PLAYING], 75	;ARE WE FINISHED?
	    JRE		MA_END		;75 PIXELS AND WE'RE DONE.
	    CALL	FUNCTION	;EVALUATE OUR FUNCTION...
;============
	    LDAW	[RESULT]
	    ADI		A, Y_SHIFT		;SHIFT THE SCREEN UP A BIT
	    STAW	[RESULT]
	    LDAW	[RESULT+1]
	    ACI         A, 0
	    STAW	[RESULT+1]

	    OFFIW	[RESULT+1], $FF	;ARE ANY OF THE BITS ON?
	    JR		MA_NOPLOT
	    OFFIW	[RESULT], $C0	;IS THE VALUE 255-64 (INVALID)
	    JR		MA_NOPLOT
	    LDAW	[RESULT]             ;Y-POS
	    MOV		C, A
	    MVI		A, 63            ;FLIP THE Y-AXIS
	    SUB		A, C
	    MOV		C, A

	    LDAW	[PLAYING]		;Our X-coord on-screen
	    MOV		B, A
	    CALL	INTERPOLATE	;INTERPOLATE BETWEEN 2 DOTS!
	    CALT        B_StDotBC	;DRAW THE DOT
	    JR		MAINOK
MA_NOPLOT:
	    ORIW	[COLUMN], $FF	;MAKE AN "INVALID" COLUMN THEN...
MAINOK:	    CALL  LCD2_RAM_WRITE          ;2ND SCREEN TO LCD
	    INRW	[PLAYING]		;GO TO NEXT X-POS
MA_END:
	    RET
;==============================================
INTERPOLATE:	;INTERPOLATE BETWEEN 2 DOTS!
	PUSH	BC	;SAVE OUR BC REG FOR THE MAIN FUNCTION
	OFFIW	[COLUMN], $C0	;IS THE VALUE 255-64 (INVALID)
	JR	IPLNDRAW        ;DON'T DO ANY INTERPOLATION
;---
	LDAW	[COLUMN]		;GET OLD VALUE
	GTA	A, C		;IF OLD IS LESS THAN NEW (-VE SLOPE), THERE'S ALIASING...
	DCR	B		;...AND WE MUST DECREMENT OUR X-COORD!
	ADD	A, C		;ADD OLD(A) PLUS NEW (C)
	RAR			;DIVIDE BY 2 TO GET THE AVERAGE
	MOV	C, A		;OUR NEW Y-COORD
	CALT        B_StDotBC	;DRAW THE DOT
IPLNDRAW:	;DON'T DRAW OUR NEW DOT ON-SCREEN
	POP	BC
	MOV	A, C	;Y-COORD STORED IN C
	STAW	[COLUMN]	;OUR NEW DOT BECOMES THE OLD "COLUMN"
	RET

;==============================================
MODEBROUTINE:            ;A MINI-NOTEPAD
            ONIW	[JOYB_STROBE], $01		;IS "SELECT" PRESSED?
            JR		MBNOSELECT		;IF NOT, CHECK NEXT
            MVI	        A, 06                   ;OTHERWISE, RESET CURSY
    	    STAW	[CURSY]
            JMP         MODE1SETUP		;GO BACK TO MENU!!
MBNOSELECT:
            ONIW	[JOYB_STROBE], $08		;IS "START" PRESSED?
            JMP		NOTPAD			;NOTEPAD PAD READING...
            JMP		DEM8SETUP		;BIG SCROLLER
;
;	    RET
;==============================================
;==============================================
DEM7SETUP:		;DEMO 7: A NOTEPAD
	MVI	A, 0
       STAW	[CURSX]
       STAW	[CURSY]
NPREDRAW:		;REDRAW NOTEPAD
 	  MVI	A, $0B     	;NOTEPAD
	  STAW	[TST_MODE]
	  CALT	B_ClScRam       ;CLEAR THE SCREEN!

	LXI	HL, NOTERAM	;POINT TO OUR NOTE DATA

        MVI	A, $9B		;"CALT	B_PtByte"
       STAW	[$FFCB]		;START OF 5 FREE BYTES IN RAM!
       MVI	A, $00		;
       STAW	[$FFCC]            ;X-POS
       STAW	[$FFCD]		;Y-POS
       MVI	A, $9C		;
       STAW	[$FFCE]            ;SPACING & PLACING

       MVI	A, 7
       STAW	[LOOPCNT]         ;DO FOR 8 LOOPS
NOTLP1:
	PUSH	HL
       CALL	$FFCB		;JUMP TO OUR CODE IN *RAM*!!
       LDAW	[$FFCD]
       ADI	A, 08		;ADD TO Y-POS
       STAW	[$FFCD]
       POP	HL
       CALT     B_HPlusMinus
       DB	12		;ADD 12 TO TEXT POINTER

        DCRW    [LOOPCNT]         ;DO FOR 8 LOOPS
        JR     NOTLP1		;LOOP IF NOT ZERO YET
        
	CALL	NOTECURSOR	;POSITION OUR CURSOR!

       CALT	B_WriteLCD
	 RET
;==============================================
;==============================================
DEM8SETUP:		;DEMO 8: A BIG SCROLLER
 	  MVI	A, $0C     	;BIGSCROLL
	  STAW	[TST_MODE]

	  	CALT	B_ClS2RAM       ;CLEAR THE SCREEN!
	  	LXI	HL, $C000		;CLEAR THE CHAR BUFFER...
		MVI	B, 05
		CALT	B_ClHxB		;CLEAR RAM

		LXI	HL, NOTERAM	;POINT TO THE SCROLLER TEXT
		DCX	HL		;FIRST LOOP DIDN'T LOAD THE 1ST CHAR!
	    	SHLD    [TXTRAM]
	    	MVI	A, 00
	    	STAW	[SCRLCOUNT]	;SCROLLER LOOP AMOUNT
	    	STAW	[SINCNT]		;OUR MAKESHIFT TEXT GFX POINTER

	    	MVI	A, 05		;A SCROLL AMOUNT
	    	STAW	[INST4]		;TEMP STORAGE FOR SCROLL AMOUNT
	 RET

;======================================================================================
;==============================================
MODECROUTINE:            ;THE BIG SCROLLER (SUBROUTINE)
            ONIW	[JOYB_STROBE], $01		;IS "SELECT" PRESSED?
            JR		MCNOSELECT		;IF NOT, CHECK NEXT
            JMP         NPREDRAW		;GO BACK TO NOTEPAD EDITOR!!
MCNOSELECT:
            ONIW	[JOYP_STROBE], $02		;IS "LEFT" PRESSED?
            JR		MCNOLEFT		;IF NOT, CHECK NEXT
            INRW	[INST4]                   ;INC OUR SCROLL SPEED
            OFFIW	[INST4], 8			;8 BYTES AT A TIME?
            DCRW	[INST4]
	    ANIW	[SCRLCOUNT], 0	;CLEAR SCRLCOUNT AGAIN
	    JR		MCDOSCROLL
MCNOLEFT:
            ONIW	[JOYP_STROBE], $08		;IS "RIGHT" PRESSED?
            JR		MCNORT			;IF NOT, CHECK NEXT
            DCRW	[INST4]                   ;DEC OUR SCROLL SPEED
            NEIW	[INST4], 0			;IT CAN'T BE ZERO
            INRW	[INST4]
	    ANIW	[SCRLCOUNT], 0	;CLEAR SCRLCOUNT AGAIN
;	    JR		MCDOSCROLL
MCNORT:

MCDOSCROLL:	;UPDATE THE IMAGE!
	CALL	SCRBIG            ;DO THE BIG SCROLL!
	  CALL  LCD2_RAM_WRITE          ;2ND SCREEN TO LCD
;       CALT	B_WriteLCD
	    RET
;==============================================
;==============================================
SCRBIG:
	LDAW	[INST4]		;SCROLL AMOUNT
	MOV	C, A		;STORE OUR COUNTER IN C (SHOULD BE SAFE)
	DCR	C		;ALIGN TO XX..0
	LXI	HL, $C258	;X BYTES IN ADVANCE
	ADD	A, L
	MOV	L, A		;ADD SCROLL AMOUNT TO HL
	LXI	DE, $C258	;START OF SCREEN 2 RAM

	MVI	A, 07		;8 LINES...
	STAW	[LOOPCNT]
SCBLP1:
	MVI	B, 74			;THIS SHOULD DO IT 75 ($4B)TIMES!
	CALT    B_CpHDxB		;COPY H->D xB

        DCRW    [LOOPCNT]         ;DO FOR 8 LOOPS
        JR     SCBLP1		;LOOP IF NOT ZERO YET

;------------------ NOW WE PUT TEXT ON-SCREEN & SCROLL IT
	LDAW	[SINCNT]		;OUR GFX POINTER (TEMPORARY STORAGE)
	MOV	L, A
	MVI	H, $C0		;ADDRESS ADDS UP TO $C000-$C005
	LDAX	[HL]
	STAW	[INST1]		;A TEMPORARY STORAGE SLOT!
;-------------------------------------+=+=+=+=+=+=+=
		  ;THE FOLLOWING IS BAD PROGRAMMING PRACTICE!
		  ;KINDLY IGNORE IT AND MAKE YOUR OWN CODE MORE COMPACT...
	MOV	A, C
	MOV	B, A		;RELOAD OUR COUNTER
	OFFIW	[INST1], 1
	MVI	A, $FF
	MVI	A, 0
	LXI	HL, $C2A2
SCL1:	STAX	[HL-]
	DCR	B
	JR	SCL1

       	MOV	A, C
	MOV	B, A		;RELOAD OUR COUNTER
	OFFIW	[INST1], 2
	MVI	A, $FF
	MVI	A, 0
	LXI	HL, $C2ED
SCL2:	STAX	[HL-]
	DCR	B
	JR	SCL2

     	MOV	A, C
	MOV	B, A		;RELOAD OUR COUNTER
	OFFIW	[INST1], 4
	MVI	A, $FF
	MVI	A, 0
	LXI	HL, $C338
SCL3:	STAX	[HL-]
	DCR	B
	JR	SCL3

     	MOV	A, C
	MOV	B, A		;RELOAD OUR COUNTER
	OFFIW	[INST1], 8
	MVI	A, $FF
	MVI	A, 0
	LXI	HL, $C383
SCL4:	STAX	[HL-]
	DCR	B
	JR	SCL4

     	MOV	A, C
	MOV	B, A		;RELOAD OUR COUNTER
	OFFIW	[INST1], $10
	MVI	A, $FF
	MVI	A, 0
	LXI	HL, $C3CE
SCL5:	STAX	[HL-]
	DCR	B
	JR	SCL5

     	MOV	A, C
	MOV	B, A		;RELOAD OUR COUNTER
	OFFIW	[INST1], $20
	MVI	A, $FF
	MVI	A, 0
	LXI	HL, $C419
SCL6:	STAX	[HL-]
	DCR	B
	JR	SCL6

     	MOV	A, C
	MOV	B, A		;RELOAD OUR COUNTER
	OFFIW	[INST1], $40
	MVI	A, $FF
	MVI	A, 0
	LXI	HL, $C464
SCL7:	STAX	[HL-]
	DCR	B
	JR	SCL7

     	MOV	A, C
	MOV	B, A		;RELOAD OUR COUNTER
	OFFIW	[INST1], $80
	MVI	A, $FF
	MVI	A, 0
	LXI	HL, $C4AF
SCL8:	STAX	[HL-]
	DCR	B
	JR	SCL8
;-------------------------------------+=+=+=+=+=+=+=

	;NOW WE RELOAD THE GRAPHICS MEM WITH A NEW CHARACTER, IF NECESSARY

	INRW	[SCRLCOUNT]
	NOP		;PROBABLY NOT NEEDED
	MOV	A, C	;(SCROLL COUNTER-1 (0..6) IS STILL IN HERE)
	LXI	HL, SC_MULTIPLES	;POINT TO A "WIDTH" TABLE
	ADD	A, L
	MOV	L, A
	LDAX	[HL]
	MOV	C, A     ;COMPARE IT WITH THIS "WIDTH"
	LDAW	[SCRLCOUNT]
	EQA	A, C     ;HAS IT DONE ENOUGH PIXELS?
;	EQIW	[SCRLCOUNT], 02	;2ND SCROLL; CHANGE THIS TO ADJUST WIDTH
	JRE	NADVTGFX

	;NOW WE HAVE TO POINT TO THE NEXT VERTICAL STRIP...
	ANIW	[SCRLCOUNT], 0	;CLEAR SCRLCOUNT AGAIN
	INRW	[SINCNT]		;OUR 0-5 TEXT GRAPHICS POINTER
	NOP		;PROBABLY NOT NEEDED
	EQIW	[SINCNT], 6	;OUR MAKESHIFT TEXT GFX POINTER
	JRE	NADVTGFX
	ANIW	[SINCNT], 0	;CLEAR OUR POINTER TO VERTICAL STRIP
	LHLD	[TXTRAM]		;OUR TEXT POINTER
	INX	HL
	LDAX	[HL]		;GET BYTE
	NEI	A, $FF		;IS IT A TERMINATOR?
	LXI	HL, NOTERAM       ;IF NOT, SKIP
	NEI	A, 0
	ORIW	[SINCNT], 3	;MAKE SPACES SHORT.
	NEI	A, $A0
	ORIW	[SINCNT], 3	;MAKE SPACES SHORT.
	SHLD	[TXTRAM]
	CALT	B_PtText	;PRINT TEXT
        DB	00, 00, $91	;PLACES ONE BYTE AT TOP
NADVTGFX:	;"DON'T ADVANCE TEXT GFX"
	RET

SC_MULTIPLES: DB 8, 4, 3, 2, 1, 1, 1 ;7X1=7 6X1=6 5X1=5 4X2=8 3X3=9 2X4=8 1X8=8
;==============================================
MODE0SETUP:	;INITIALIZES THE TITLE SCREEN

	  	CALT	B_ClScRam       ;CLEAR THE SCREEN!

		LXI	HL, MYTXT1	;POINT TO THE SCROLLER TEXT
	    	SHLD    [TXTRAM]
	    	MVI	A, 00
	    	STAW	[SCRLCOUNT]	;SCROLLER LOOP AMOUNT
		STAW	[VB_COUNT]
		STAW	[SINCNT]
		STAW	[LOOPCNT]		;FADE-IN LOOP
		
		MVI	A, 01
		STAW	[PLAYING]		;FOR SPECIAL EFFECTS (FADE-IN) & MUSIC, ETC.

	    	LXI	HL, SINE_TBL	;GET INITIAL SINE POS
	    	SHLD    [SIN1POS]		;SAVE IT IN POINTER


	    	CALL	RAMCODE		;PUT SOME CODE IN RAM
		MVI	A, 03            ;MODIFY THE...
      		STAW	[$FFCD]            ;Y-POS
		MVI	A, $01		;PUT ON 2ND SCREEN!!!
		STAW	[$FFCE]            ;SPACING & PLACING

		LXI	HL, MYGFX2        ;RUN-LENGTH ENCODED GFX
		LXI     DE, $C258	;START OF SCREEN 2
		CALL	RLE_DECODE	;WRITE RLE DATA
;---------------------------------------
;	    	LXI	DE, $C465	;START OF THE LAST LINE OF THE 2ND SCREEN
;	    	MVI	C, 07	;8 LINES
;	    	MVI	B, 74	;75 BYTES
;	    	CALL	CPY_MY_GFX
;---------------------------------------
   	    	CALT	B_WriteLCD
	    	MVI	A, 00
	    	STAW	[TST_MODE]
;	    	MOV	$C25D, A	;CLEAR THE BYTE USED ON SCREEN 2
	  	RET


MODE1SETUP:		;INITIALIZES THE MAIN MENU
	  CALT	B_ClScRam
;	  CALT	B_WriteLCD      ;CLEAR THE LCD FIRST OF ALL
	  CALL	WRCORNERS	;PUT SOME DOTS IN EACH CORNER.
	  CALL	WRTMENU		;WRITE THE MAIN MENU
  	  CALT	B_WriteLCD
  	  CALL	TIMER_START	;RESET TIMER
 	  MVI	A, 01
	  STAW	[TST_MODE]	;GO TO MAIN MENU
;	MVI	A, 01
	STAW	[COLUMN]		;RESET COLUMN FOR EDITOR...
	  RET
;-----------------------
TODEMSETUP:		;JUMPS TO ONE OF THE NINE DEMO ROUTINES
	  LXI	HL, SETPJMP_TABLE	;LOAD THE JUMP TABLE
	  LDAW	[CURSY]		;GET MODE VALUE FROM CURSOR
	  CLC			;(IS THIS NECESSARY?)
   	  RAL			;MULTIPLY BY 2
   	  MOV	E, A
            MVI	A, 00
	    STAW	[CURSY]                   ;CLEAR CURSOR FOR ALL DEMOS???
   	  CALT	B_HPlE		;ADD E
   	  LDAX	[HL+]
   	  MOV	C, A
   	  LDAX	[HL]
   	  MOV	B, A             ;GET POINTER, PUT IN BC
   	  JB			;JUMP TO TABLE POSITION
;-------------------
DEM1SETUP:		;DEMO 1: A MEMORY VIEWER
	  CALT	B_ClScRam
	  LXI	HL, TXT_N1
	  CALT	B_PtText	;PRINT TEXT
       DB	02, 00, $9C	;PLACES HEADER AT TOP
	  LXI	HL, TXT_B1
	  CALT	B_PtText	;PRINT TEXT
       DB	00, 59, $9D	;PLACES FOOTER AT BOTTOM
       
       LHLD     [HEXADD]
       SHLD	[CURADD]		;COPY HEX EDITOR ADDRESS TO CURRENT ADDRESS

 	  MVI	A, 02		;MEMORY VIEWER
	  STAW	[TST_MODE]

	  JMP	DRW_EDITOR	;A COMMON ROUTINE THAT DISPLAYS HEX, ETC
;	 RET
;-------------------
DEM2SETUP:		;DEMO 2: A CODE EXECUTOR
	  CALT	B_ClScRam
	  LXI	HL, TXT_N2
	  CALT	B_PtText	;PRINT TEXT
	  DB	02, 00, $9C	;PLACES HEADER AT TOP

	  LXI	HL, TXT_B2
	  CALT	B_PtText	;PRINT TEXT
       DB	00, 59, $9D	;PLACES FOOTER AT BOTTOM
       
       LHLD     [PRGADD]
       SHLD	[CURADD]		;COPY PROGRAM EDITOR ADDRESS TO CURRENT ADDRESS

 	  MVI	A, 03		;CODE EXECUTOR
	  STAW	[TST_MODE]	;GO TO MAIN MENU
	  
	  JMP	DRW_EDITOR	;A COMMON ROUTINE THAT DISPLAYS HEX, ETC
;	 RET
;-------------------
DEM3SETUP:		;DEMO 3: A MUSIC PLAYER
	  CALT	B_ClScRam
	  LXI	HL, TXT_N3
	  CALT	B_PtText	;PRINT TEXT
	  DB	02, 00, $9C	;PLACES HEADER AT TOP

	  LXI	HL, TXT_B3
	  CALT	B_PtText	;PRINT TEXT
       DB	00, 59, $9D	;PLACES FOOTER AT BOTTOM
       
       LHLD     [MUSADD]
       SHLD	[CURADD]		;COPY MUSIC EDITOR ADDRESS TO CURRENT ADDRESS

        MVI	A, 00
	STAW	[CURSY]
 	MVI	A, 04		;MUSIC EDITOR
	STAW	[TST_MODE]

	  JMP	DRW_EDITOR	;A COMMON ROUTINE THAT DISPLAYS HEX, ETC
;	 RET
;==============================================
DEM4SETUP:		;DEMO 4: A "Greyscale" PICTURE
            MVI	        A, 03                   ;SET CURSY
    	    STAW	[CURSY]
    	    MVI		A, 00
    	    STAW	[INST4]           ;TEMPORARY STORAGE FOR THE PICTURE LOOP
    	    STAW        [VB_PASS]		;CLEAR OUR TIME COUNTER

	    CALL	NEXTPIC		;LOAD NEXT PIC ON-SCREEN

 	  MVI	A, 05     	;PICTURE
	  STAW	[TST_MODE]	;GO TO MAIN MENU
	 RET
;======================================================================================
;==============================================
DEM5SETUP:		;DEMO 5: A "MARIO GAME"

;		LXI	HL, MARPC1
;	    	LXI	DE, $C20D	;START OF THE LAST LINE OF THE SCREEN
;	    	MVI	C, 07	;8 LINES
;	    	MVI	B, 74	;75 BYTES
;	    	CALL	CPY_MY_GFX
;	    	LXI	HL, MARPC2
;	    	LXI	DE, $C465	;START OF THE LAST LINE OF THE 2ND SCREEN
;	    	MVI	C, 07	;8 LINES
;	    	MVI	B, 74	;75 BYTES
;	    	CALL	CPY_MY_GFX
		CALL	LPICMAR		;LOAD MARIO PIC

 	  	MVI	A, 08     	;MARIO PICTURE
	  	STAW	[TST_MODE]
	  	MVI	A, 00
	  	MOV	[FACING], A        ;OUR MARIO DEFINITIONS...
	  	MOV	[FACOLD], A
	 RET
;======================================================================================
;======================================================================================
DEM6SETUP:		;DEMO 6: A LINE, CURVE, ETC. DRAWER
 	MVI	A, $0A        ;LINES
	STAW	[TST_MODE]
	CALL	GPH_REDRAW	;REDRAW OUR GRAPH
	RET
;======================================================================================
;======================================================================================
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


;--------- "TEXT" EDITOR ROUTINE --------------------------------------
;--------------------------------------------------------------------
NOTPAD:		;READS THE JOYPAD, BUTTONS IN THE TEXT EDITOR
        ONIW	[JOYP_STROBE], $08		;IS "RIGHT" PRESSED?
        JR	NPNORT		;IF NOT, CHECK NEXT
	CALL	NOTECURSOR	;CLEAR CURSOR GFX
	INRW        [CURSX]			;INCREMENT THE CURSOR...

	    EQIW	[CURSX], 12		;IS THE CURSOR TOO HIGH?
	    JR		NPCRSRT
	    MVI	A, 00                            ;OTHERWISE, RESET CURSX
    	    STAW	[CURSX]
	    CALL	INYCURS		;INC CURSOR Y
NPCRSRT:	    JMP		NPUPDSC
;-------------------------
NPNORT:
        ONIW	[JOYP_STROBE], $02		;IS "LEFT" PRESSED?
        JR	NPNOLF		;IF NOT, CHECK NEXT
	CALL	NOTECURSOR	;CLEAR NOTE CURSOR GFX
	DCRW        [CURSX]			;DECREMENT THE CURSOR...
		;THE ABOVE INSTRUCTION ALREADY "CHECKS" IF AT #$FF!
	    JR		NPCRSLF			;IF NOT, SKIP....
	    MVI A, 11                            ;THIS IS NOW GOING TO RIGHT SIDE
    	    STAW	[CURSX]
	    CALL	DEYCURS
NPCRSLF:	    JMP		NPUPDSC
;-------------------------
NPNOLF:
        ONIW	[JOYP_STROBE], $01		;IS "UP" PRESSED?
        JR	NPNOUP		;IF NOT, CHECK NEXT
	CALL	NOTECURSOR	;CLEAR NOTE CURSOR GFX
	CALL	DEYCURS
	JMP	NPUPDSC
;-------------------------
NPNOUP:
        ONIW	[JOYP_STROBE], $04		;IS "DOWN" PRESSED?
        JR	NPNODN		;IF NOT, CHECK NEXT
	CALL	NOTECURSOR	;CLEAR NOTE CURSOR GFX
	CALL	INYCURS
	JMP	NPUPDSC
;-------------------------
NPNODN:  ONIW	[JOYB_STROBE], $10		;IS "2 (UR)" PRESSED?
        JR	NPNO2		;IF NOT, CHECK NEXT
;@@@@@@@@@@			CHECK 1+2 PRESSED (CLEAR LINE)
        ONIW	[JOYB_CURR], $02   ;SKIP IF BUTTON 1 IS _ALSO_ PRESSED
	JRE	NPDC01		;DECREMENT $01 FROM VALUE IF A USUAL PRESS
	;NOW WE CLEAR ONE LINE
	MVI	A, 0
	STAW	[CURSX]
        CALL	NOTEGET		;GET BYTE AT CURSOR X, Y
        MVI	B, 11		;CLEAR 12 BYTES
	CALT	B_ClHxB		;Clear RAM (HL+)xB
        LDAW	[CURSY]
        MOV	C, A
        MVI	B, 0
	CALT	B_ScrPosBC	;POINT TO SCREEN
	MVI	B, 74		;CLEAR 75 BYTES
	CALT	B_ClHxB		;Clear RAM (HL+)xB
        JMP	NPUPDSC
;@@@@@@@@@@
NPNO2:   ONIW	[JOYB_STROBE], $20		;IS "4 (DR)" PRESSED?
        JR	NPNO4		;IF NOT, CHECK NEXT
	JR	NPIC01		;ADD $01 TO VALUE
NPNO4:  ONIW	[JOYB_STROBE], $02		;IS "1 (UL)" PRESSED?
        JR	NPNO1		;IF NOT, CHECK NEXT
	JR	NPDC10		;DECREMENT $10 FROM VALUE
NPNO1:   ONIW	[JOYB_STROBE], $04		;IS "3 (DL)" PRESSED?
        RET	;JR	NPNO3		;IF NOT, CHECK NEXT
;	JR	NPIC10		;ADD $10 TO VALUE
	MVI	A, $10		;VALUES TO "ADD" TO OUR TEXT CHAR.
NPDC01:	MVI	A, $FF
NPIC01:	MVI	A, $01
NPDC10:	MVI	A, $F0
	PUSH	VA		;SAVE THIS VALUE
        CALL	NOTECURSOR	;CLEAR CURSOR GFX
        CALL	NOTEGET		;GET BYTE AT CURSOR X, Y
        POP	DE		;GET OUR SAVED VALUE IN (D)E
        ADD	A, E		;ADD OR SUBTRACT THE VALUE TO THE BYTE
        STAX	[HL]		;SAVE IT BACK IN RAM

	MVI	A, $9B		;TEXT PRINTING?
	STAW	[$FFCB]
	LDAW	[CURSX]
	CALL	MULT6		;MULTIPLY BY *6*
        STAW	[$FFCC]            ;X-POS
	LDAW	[CURSY]
        STAW	[$FFCD]		;Y-POS
        MVI	A, $91		;PRINT 1 TEXT CHARACTER
        STAW	[$FFCE]            ;SPACING & PLACING
	CALL    $FFCB		;JUMP TO OUR CODE IN *RAM*!!


NPUPDSC:
	CALL	NOTECURSOR	;PUT NEW CURSOR IN
	CALT	B_WriteLCD
	RET
;-----------------------------------------
NOTEGET: ;POINT TO THE BYTE UNDER OUR NOTEPAD CURSOR AND READ IT IN A.
	LDAW	[CURSY]		;0, 8, 16, 24...
	MOV	E, A
	CLC
	RAR	;DIVIDE A BY 2 (0, 4, 8, 12...)
	ADD	A, E		;0, 12, 24, 36, 48...?
	MOV	E, A
	LDAW	[CURSX]		;0..11
	ADD	A, E		;WE SHOULD HAVE A GOOD RANGE FROM 0 TO 95
	MOV	E, A
	LXI	HL, NOTERAM	;POINT TO OUR NOTE DATA
	CALT    B_HPlE		;ADD OUR POINTER
	LDAX	[HL]		;GET OUR BYTE
	RET

;--------------------------------------------------------------------
DEYCURS:	LDAW	[CURSY]
	SUI	A, 8	;GO UP 1 LINE
	JR	INYSAVE
INYCURS:
	LDAW	[CURSY]
	ADI	A, 8	;GO DOWN 1 LINE
INYSAVE:	ANI	A, $3F	;NO HIGHER THAN LINE 8
	STAW	[CURSY]
	RET
;--------------------------------------------------------------------
;--------------------------------------------------------------------

;--------- HEX EDITOR ROUTINE --------------------------------------
;--------------------------------------------------------------------
HEXPAD:		;READS THE JOYPAD, BUTTONS IN THE HEX EDITOR
        ONIW	[JOYP_STROBE], $08		;IS "RIGHT" PRESSED?
        JMP	HXNORT		;IF NOT, CHECK NEXT
	CALL	XORCURSOR	;CLEAR HEX CURSOR GFX
	    INRW        [CURSX]			;INCREMENT THE CURSOR...
;	    NOP
	    EQIW	[COLUMN], 0		;IS IT IN COLUMN 0 OR 1?
	    JR		HTSCL14                 ;IF IN 1, CHECK FOR 4.
	    NEIW	[CURSX], 02		;IF COLUMN 0, CHECK FOR 2, NOT 4.
	    JR          HTCL14
HTSCL14:
	    EQIW	[CURSX], 04		;IS THE CURSOR TOO HIGH?
	    JR		HXCRSRT
HTCL14:
	    MVI	A, 00                            ;OTHERWISE, RESET CURSX
    	    STAW	[CURSX]
    	    LDAW	[COLUMN]
    	    XRI		A, 01			;INVERT THE COL#
    	    STAW	[COLUMN]			;CLEAR THE COL #
HXCRSRT:	    CALL	XORCURSOR	;PUT NEW CURSOR IN
	    JMP		HXUPDSC
;-------------------------
HXNORT:
        ONIW	[JOYP_STROBE], $02		;IS "LEFT" PRESSED?
        JR	HXNOLF		;IF NOT, CHECK NEXT
	CALL	XORCURSOR	;CLEAR HEX CURSOR GFX
	    DCRW        [CURSX]			;DECREMENT THE CURSOR...
		;THE ABOVE INSTRUCTION ALREADY "CHECKS" IF AT #$FF!
	    JR		HXCRSLF			;IF NOT, SKIP....
	    EQIW	[COLUMN], 0		;IS IT IN COLUMN 0 OR 1?
	    MVI	A, 01                            ;OTHERWISE, RESET CURSX
	    MVI A, 03                            ;THIS IS NOW GOING TO COL 1
    	    STAW	[CURSX]
    	    LDAW	[COLUMN]
    	    XRI		A, 01			;INVERT THE COL#
    	    STAW	[COLUMN]			;CLEAR THE COL #
HXCRSLF:	    CALL	XORCURSOR	;PUT NEW CURSOR IN
	    JMP		HXUPDSC
;-------------------------
HXNOLF:
        ONIW	[JOYP_STROBE], $01		;IS "UP" PRESSED?
        JMP	HXNOUP		;IF NOT, CHECK NEXT
	CALL	XORCURSOR	;CLEAR HEX CURSOR GFX

	    LDAW	[CURSY]
	    SUINB	A, 04		;SUBTRACT 4 FROM Y-POS
	    JR	HXRSTUP 		;IF A BORROW, RESET EVERYTHING
	    STAW	[CURSY]
		CALL	XORCURSOR	;IF NO BORROW, JUST UPDATE THE CURSOR!
	    	JMP		HXUPDSC
	;-------------
HXRSTUP:     ;RESET THE HEX EDITOR SCREEN!
	    MVI 	A, $14            ;THIS IS NOW GOING TO BOTTOM ROW
    	    STAW	[CURSY] 		  ;SAVE AS CURSOR

            	LHLD	[CURADD]          ;MOVE BACK $18 BYTES IN ROM/RAM
		CALT	B_HPlusMinus	;SUBTRACT $18 BYTES
		DB	$E8		;(MINUS 18)
		SHLD	[CURADD]
		CALL	DECINSTRUCTION	;DECODE OUR INSTRUCTION
	    JMP		DRW_EDITOR	;REDRAW THE EDITOR
;-------------------------
HXNOUP:
        ONIW	[JOYP_STROBE], $04		;IS "DOWN" PRESSED?
        JMP	HXNODN		;IF NOT, CHECK NEXT
	CALL	XORCURSOR	;CLEAR HEX CURSOR GFX

	    LDAW	[CURSY]
	    ADI		A, 04		;ADD 4 TO Y-POS
	    NEI		A, $18		;CHECK IF TOO HIGH

	    JR	HXRSTDN 		;IF TOO HIGH, RESET EVERYTHING
	    STAW	[CURSY]
		CALL	XORCURSOR	;IF NOT TOO HIGH, JUST UPDATE THE CURSOR!
	    	JMP		HXUPDSC
	;-------------
HXRSTDN:     ;RESET THE HEX EDITOR SCREEN!
	    MVI 	A, 0            ;THIS IS NOW GOING TO TOP ROW
    	    STAW	[CURSY] 		  ;SAVE AS CURSOR

            	LHLD	[CURADD]          ;MOVE FORWARD $18 BYTES IN ROM/RAM
		CALT	B_HPlusMinus
		DB	$18            ;ADD $18 BYTES
		SHLD	[CURADD]

            	CALL	DECINSTRUCTION	;DECODE OUR INSTRUCTION
	    JMP		DRW_EDITOR	;REDRAW THE EDITOR
;-------------------------
HXNODN:
        ONIW	[JOYB_STROBE], $10		;IS "2 (UR)" PRESSED?
        JMP	HXNO2		;IF NOT, CHECK NEXT
	CALL	XORCURSOR	;CLEAR HEX CURSOR GFX

	ONIW	[COLUMN], 1		;IS IT IN COLUMN 0 OR 1?
	JR	DECADD                  ;IF 0, DECREASE _ADDRESS_
;IF 1, DECREMENT THE LOW NYBBLE
DECNYB:
       CALL	HXOFFSET		;GET OUR OFFSET, GET BYTE
       DCR	A			;DECREMENT A
       NOP
       CALL	UPDBYTE			;SAVE BYTE & UPDATE THE BYTE ONSCREEN
	JMP      HXUPDSC
;----------------------------
;----- NOW AT 0 (ADDRESS COLUMN), CHECK WHICH BYTE OF ADDRESS TO CHANGE
DECADD: ONIW	[CURSX], 1		;IS IT THE LOW BYTE?
       JR	DECADHI		;IF NOT, DECREASE HIGH BYTE
DECADLO: DCRW	[CURADD]		;IF LOW BYTE, DEC (BOTH?)
	JR	SKIPDEC
DECADHI: DCRW	[CURADD+1]	;DECREMENT HIGH BYTE IF NO BORROW!
	NOP
SKIPDEC:
	CALL	DECINSTRUCTION	;DECODE OUR INSTRUCTION
	JMP	DRW_EDITOR	;REDRAW THE EDITOR
;-------------------------
HXNO2:
        ONIW	[JOYB_STROBE], $20		;IS "4 (DR)" PRESSED?
        JMP	HXNO4		;IF NOT, CHECK NEXT
	CALL	XORCURSOR	;CLEAR HEX CURSOR GFX

	ONIW	[COLUMN], 1		;IS IT IN COLUMN 0 OR 1?
	JR	INCADD                  ;IF 0, INCREASE _ADDRESS_
;IF 1, INCREMENT THE LOW NYBBLE
INCNYB:
       CALL	HXOFFSET		;GET OUR OFFSET, GET BYTE
       INR	A			;INCREMENT A
       NOP
       CALL	UPDBYTE			;SAVE BYTE & UPDATE THE BYTE ONSCREEN
	JMP      HXUPDSC
;----------------------------
;----- NOW AT 0 (ADDRESS COLUMN), CHECK WHICH BYTE OF ADDRESS TO CHANGE
INCADD: ONIW	[CURSX], 1		;IS IT THE LOW BYTE?
       JR	INCADHI		;IF NOT, INCREASE HIGH BYTE
INCADLO: INRW	[CURADD]		;IF LOW BYTE, INC (BOTH?)
	JR	SKIPINC
INCADHI: INRW	[CURADD+1]	;INCREMENT HIGH BYTE IF NO CARRY!
	NOP
SKIPINC:
	CALL	DECINSTRUCTION	;DECODE OUR INSTRUCTION
	JMP	DRW_EDITOR	;REDRAW THE EDITOR
;-------------------------
HXNO4:
        ONIW	[JOYB_STROBE], $02		;IS "1 (UL)" PRESSED?
        JMP	HXNO1		;IF NOT, CHECK NEXT
	CALL	XORCURSOR	;CLEAR HEX CURSOR GFX

	ONIW	[COLUMN], 1		;IS IT IN COLUMN 0 OR 1?
	JR	DECAD10                  ;IF 0, DECREASE _ADDRESS_
;IF 1, DECREMENT THE HIGH NYBBLE
DECHNYB:
       CALL	HXOFFSET		;GET OUR OFFSET, GET BYTE
       SUI	A, $10			;DECREMENT A BY 16
       CALL	UPDBYTE			;SAVE BYTE & UPDATE THE BYTE ONSCREEN
	JMP      HXUPDSC
;----------------------------
;----- NOW AT 0 (ADDRESS COLUMN), CHECK WHICH BYTE OF ADDRESS TO CHANGE
DECAD10: LHLD	[CURADD]		;LOAD ADDRESS IN HL
	ONIW	[CURSX], 1		;IS IT THE LOW BYTE?
        JR	DCA10HI		;IF NOT, DECREASE HIGH BYTE
DCA10LO: LXI     DE, $FFF0	;MINUS $10
	JR	SKIPD10
DCA10HI: LXI     DE, $F000	;MINUS $1000
SKIPD10:
	CALT    B_HPlDE		;ADD THE 16-BIT NUMBERS
	SHLD	[CURADD]
	CALL	DECINSTRUCTION	;DECODE OUR INSTRUCTION
	JMP	DRW_EDITOR	;REDRAW THE EDITOR
;-------------------------
HXNO1:
        ONIW	[JOYB_STROBE], $04		;IS "3 (DL)" PRESSED?
        JMP	HXNO3		;IF NOT, CHECK NEXT
	CALL	XORCURSOR	;CLEAR HEX CURSOR GFX

	ONIW	[COLUMN], 1		;IS IT IN COLUMN 0 OR 1?
	JR	INCAD10                  ;IF 0, INCREASE _ADDRESS_
;IF 1, INCREMENT THE HIGH NYBBLE
INCHNYB:
       CALL	HXOFFSET		;GET OUR OFFSET, GET BYTE
       ADI	A, $10			;INCREMENT A BY 16
       CALL	UPDBYTE			;SAVE BYTE & UPDATE THE BYTE ONSCREEN
	JMP      HXUPDSC
;----------------------------
;----- NOW AT 0 (ADDRESS COLUMN), CHECK WHICH BYTE OF ADDRESS TO CHANGE
INCAD10: LHLD	[CURADD]		;LOAD ADDRESS IN HL
	ONIW	[CURSX], 1		;IS IT THE LOW BYTE?
        JR	INA10HI		;IF NOT, DECREASE HIGH BYTE
INA10LO: LXI     DE, $10		;PLUS $10
	JR	SKIPI10
INA10HI: LXI     DE, $1000	;PLUS $1000
SKIPI10:
	CALT    B_HPlDE		;ADD THE 16-BIT NUMBERS
	SHLD	[CURADD]
	CALL	DECINSTRUCTION	;DECODE OUR INSTRUCTION
	JMP	DRW_EDITOR	;REDRAW THE EDITOR
;-------------------------
HXNO3:
	;DO NOTHING
	RET
HXUPDSC:
	CALL	DECINSTRUCTION	;DECODE INSTRUCTIONS (IF IN PRG EDITOR)
	CALT	B_WriteLCD
	RET
;==============================================
;==============================================

;======================================================================================
DRW_EDITOR:	;DRAWS THE HEX EDITOR ON-SCREEN

       LXI	BC, $0000	;SET SCREEN POINTER
       CALT	B_ScrPosBC
       CALT     B_DrwLine	;DRAW ONE LINE
       DB       $40, $4A	;PATTERN, LENGTH
       LXI	BC, $0038	;SET SCREEN POINTER
       CALT	B_ScrPosBC
       CALT     B_DrwLine	;DRAW ONE LINE
       DB       $02, $4A	;PATTERN, LENGTH

       MVI	A, $9A		;"CALT	B_PtByte"
       STAW	[$FFCB]		;START OF 5 FREE BYTES IN RAM!
       MVI	A, $08
       STAW	[$FFCD]            ;Y-POS

       MVI	A, $05		;
       STAW	[LOOPCNT]

HEXD1LOOP:
;--------------- WRITE THE ADDRESS
       	LXI	HL, CURADD  	;GET OUR CURRENT POINTER (HIGH BYTE)
	INX     HL
       MVI	A, $00		;
       STAW	[$FFCC]            ;X-POS
       MVI	A, $D9		;
       STAW	[$FFCE]            ;SPACING & PLACING
       CALL	$FFCB		;JUMP TO OUR CODE IN *RAM*!!
	LXI	HL, CURADD  	;GET OUR CURRENT POINTER (LOW BYTE)
       MVI	A, $0C		;
       STAW	[$FFCC]            ;X-POS
       CALL	$FFCB		;JUMP TO OUR CODE IN *RAM*!!
;-------------- WRITE A COLON
       INRW     [$FFCB]		;CHANGE BACK TO TEXT PRINTING...
 ;      NOP			;(NOT REALLY NEEDED)
       MVI	A, 23		;
       STAW	[$FFCC]            ;X-POS
        MVI	A, $91		;
       STAW	[$FFCE]            ;SPACING & PLACING
       LXI	HL, TXT_B1+3
        CALL	$FFCB		;JUMP TO OUR CODE IN *RAM*!!
;-------------- WRITE 4 BYTES OF DATA
        DCRW	[$FFCB]		;CHANGE BACK TO HEX...
;	NOP
	MVI     A, 27		;
       STAW	[$FFCC]            ;X-POS
       MVI	A, $DF		;PRINT 4 HEX BYTES (8 DIGITS...)
       STAW	[$FFCE]            ;SPACING & PLACING
	LHLD    [CURADD]		;LOAD THE ACTUAL ADDRESS OF THE DATA...
	CALL    $FFCB		;JUMP TO OUR CODE IN *RAM*!!

	LHLD	[CURADD]
	INX     HL
	INX     HL
	INX     HL
	INX     HL
	SHLD	[CURADD]

	LDAW	[$FFCD]
	ADI	A, $08		;ADD A VALUE...
        STAW	[$FFCD]		;TO THE Y-POS

        DCRW    [LOOPCNT]         ;DO FOR 8 LOOPS
        JMP      HEXD1LOOP	;LOOP IF NOT ZERO YET

	LHLD	[CURADD]
	CALT	B_HPlusMinus	;SUBTRACT $18 BYTES
	DB	$E8		;(MINUS 18)
	SHLD	[CURADD]

	CALL	XORCURSOR	;POSITION THE CURSOR ON-SCREEN
  	  CALT	B_WriteLCD
	RET
;==============================================
;==============================================
HXOFFSET:        ;SETS HL TO THE BYTE UNDER THE CURSOR & GETS BYTE.
       LHLD	[CURADD]			;LOAD THE CURRENT ADDRESS
       MVI	A, 00			;CLEAR A FIRST
       OFFIW	[COLUMN], 01		;IS IT IN THE DATA COLUMN?  IF NOT, SKIP THE NEXT INST.
       LDAW	[CURSX]			;GET THE X-CURS

;       ORAW     [CURSY]			;OR IT WITH THE Y-POS (IT'S AN OFFSET NOW!)
; THE ABOVE INSTRUCTION DOESN'T EXIST ON THE 78c06!!!!
       MOV	E, A
       LDAW	[CURSY]                   ;OR IT WITH THE Y-POS
       ORA	A, E

       MOV	E, A
       CALT     B_HPlE			;ADD OUR ADDRESS AND OFFSET
       LDAX	[HL]			;GET OUR BYTE
       RET
;==============================================
;==============================================
UPDBYTE:    	;SAVES AND UPDATES ONE BYTE ON-SCREEN
	STAX	[HL]			;SAVE OUR BYTE
	LDAW	[CURSX]
	CALL	MULT6
	RAL			;MULTIPLY BY *12*
	ADI     A, 27		;CHANGE OFFSET
        STAW	[$FFCC]            ;X-POS

	LDAW	[CURSY]
	RAL			;CHANGE OFFSET (4->8 PIXELS)
	ADI	A, $08		;ADD OFFSET
        STAW	[$FFCD]		;Y-POS

       MVI	A, $D9		;PRINT 1 HEX BYTE (2 DIGITS...)
       STAW	[$FFCE]            ;SPACING & PLACING
;;;;	LHLD    [CURADD]		;ADDRESS OF THE DATA IS STILL IN HL...
	CALL    $FFCB		;JUMP TO OUR CODE IN *RAM*!!
	CALL	XORCURSOR	;ADD HEX CURSOR GFX

	RET

;==============================================
;==============================================
NOTECURSOR:	;POSITION THE NOTEPAD CURSOR ON-SCREEN
	LDAW	[CURSX]
	CALL	MULT6
        MOV	B, A		;X-POS
	LDAW	[CURSY]
	MOV	C, A		;Y-POS

        CALT	B_ScrPosBC	;POSITION SCREEN
	MVI	B, 5	;ONR HEX BYTE (MINUS THE SPACE AT THE END)
	CALL	X0R11LOOP     		;XORS 6 BYTES

	RET
;==============================================
;==============================================
XORCURSOR:	;POSITION THE CURSOR ON-SCREEN

	OFFIW	[COLUMN], 01	;IS IT IN COLUMN 0 OR 1?
	JR	DATCOL		;JUMP TO DATA COLUMN WORK OTHERWISE...

	ONIW	[CURSX], 01	;IT'S EITHER 0 OR 1
        MVI	A, 0		;HIGH BYTE      ;TWO "MVI A"s IN A ROW MEANS THE
        MVI	A, 12		;LOW  BYTE	;SECOND ONE IS IGNORED.
        JR	XORYPOS		;FINISH THE ROUTINE

DATCOL:                          ;ALIGNS THE CURSOR TO THE DATA COLUMN
	LDAW	[CURSX]
	CALL	MULT6
	RAL			;MULTIPLY BY *12*
	ADI     A, 27		;CHANGE OFFSET
XORYPOS:
        MOV	B, A		;X-POS
	LDAW	[CURSY]
	RAL			;CHANGE OFFSET (4->8 PIXELS)
	ADI	A, $08		;ADD OFFSET
	MOV	C, A		;Y-POS

        CALT	B_ScrPosBC	;POSITION SCREEN
        CALL	XOR11BYTES	;XORS 11 BYTES (AS IT SAYS)
	RET


	RET
;==============================================
;==============================================
XOR11BYTES:
	MVI	B, 11	;TWO HEX BYTES (MINUS THE SPACE AT THE END)
X0R11LOOP:
	LDAX    [HL]
	XRI	A, $7F	;INVERT SCREEN...
	STAX	[HL+]
	DCR     B
	JR      X0R11LOOP
	RET
;==============================================
;==============================================
NEXTPIC:     ;LOADS THE NEXT PICTURE INTO RAM
	    LDAW	[INST4]		;GET THE PIC NUMBER
	    NEI		A, 00
	    JR		LPIC1
	    NEI		A, 01
	    JR		LPIC2
	    NEI		A, 02
	    JR		LPIC3
	    NEI		A, 03
	    JR		LPIC4

LPICMAR:	    LXI		HL, MARPC1        ;MARIO PICTURE
LPIC1:	    LXI		HL, MYPIC3        ;RUN-LENGTH ENCODED PICTURE
LPIC2:	    LXI		HL, MYPIC4        ;RUN-LENGTH ENCODED PICTURE
LPIC3:	    LXI		HL, MYPIC2        ;RUN-LENGTH ENCODED PICTURE
LPIC4:	    LXI		HL, MYPIC1        ;RUN-LENGTH ENCODED PICTURE

	    LXI		DE, $C000	;START OF SCREEN 1
	    CALL	RLE_DECODE	;WRITE RLE DATA
	RET

;==============================================
;==============================================
;SLIDE: SHIFT THE GRAPHICS DOWN BY 1 TO GET A SLIDING BLINDS EFFECT
SLIDE1:  LXI	HL, $C000        ;GET SCREEN 1 DATA POINTER
SLIDE2:  LXI	HL, $C258        ;GET SCREEN 2 DATA POINTER
	MVI     C, 02
	MVI     B, $57
SLDLP1:  LDAX	[HL]	;LOAD OUR SCREEN DATA
	STC
	RAL		;SHIFT IT "DOWNWARDS"
	STAX	[HL+]      ;SAVE THE DATA
	DCR	B
	JR	SLDLP1
	DCR     C
	JR      SLDLP1
 	RET
;==============================================
;==============================================
FADEPIC:        	;INCREASES THE SCREEN VALUES UNTIL THEY MATCH SCREEN 2
	LXI	DE, $C258        ;GET SCREEN 2 DATA FIRST
	LDAW	[LOOPCNT]         ;GET OUR LOOP
	MOV	C, A		;MAKE A COPY (IN THE C REG.)

	ADD     A, E
	MOV     E, A
	MVI	A, 00
        ADC     A, D
        MOV     D, A             ;ADD TO THE SOURCE

	LXI	HL, $C000        ;GET SCREEN 1 DATA POINTER
	MOV	A, C         ;GET OUR LOOP
	ADD     A, L
	MOV     L, A
	MVI	A, 00
        ADC     A, H
        MOV     H, A             ;ADD TO THE SOURCE
 ;--------------------
	MVI	A, 07		;8 LOOPS?
	STAW	[COLUMN]		;A SMALL COUNTER FOR US HERE...

FADLP0:
	MVI	A, 74		;GET OUR MAX PIXELS
	SUB	A, C		;SUBTRACT LOOP COUNTER
	MOV	B, A		;GET DIFFERENCE AS ANOTHER COUNTER


	LDAX	[DE]	;GET OUR HARD-CODED DATA
FADLP1:
	STAX	[HL+]      ;SAVE THE DATA
	DCR	B
	JR	FADLP1

	MVI	A, 75	;POINT TO NEXT LINE DOWN
	ADD	A, E
	MOV	E, A     ;ADD EXACTLY 75 TO SOURCE POINTER
	MVI	A, 00
	ADC	A, D
	MOV	D, A

	MOV	A, C		;GET LOOP COUNTER
	ADD	A, L
	MOV	L, A             ;GET NEXT DESTINATION POINTER
	MVI	A, 00
	ADC	A, H
	MOV	H, A

	DCRW	[COLUMN]         ;REPEAT THE LOOP
	JR      FADLP0
 ;--------------------------

	INRW	[LOOPCNT]		;INCREASE OUR LOOP
	EQIW	[LOOPCNT], 75	;STOP AT PIXEL 75
	JR	FADEND		;IF NOT UP TO 75, JUMP TO END
	MVI	A, 00
	STAW   	[PLAYING]		;STOP FADE, START SCROLL
	CALT	B_CpS1		;C258+ ==> C000+
FADEND:
	RET
;==============================================
;==============================================

;==============================================
SETVARS:     ;INITIALIZE ALL OUR IMPORTANT VARIABLES
	 MVI	A, 00
	 STAW   [VB_PASS]
	 STAW	[VB_COUNT]
	 STAW	[VB2_COUNT]
        STAW	[CURSY]		;SETUP MENU CURSOR POSITION
	STAW	[PLAYING]		;FOR SPECIAL EFFECTS (FADE-IN) & MUSIC, ETC.
	;SET UP OUR GRAPHING EQUATION DEFAULTS!
	STAW	[Y2FLAG]		;+/-, ( )/(0.) FOR 2ND EXPRESSION
	STAW	[Y2PWR]		;1, 2, 3 POWER OF X FOR 2ND EXPRESSION
	STAW	[Y2SCALE]		;(1) Y-SCALE FACTOR FOR 2ND EXPRESSION

        MVI	A, 03
	STAW	[Y1SCALE]		;(1) Y-SCALE FACTOR FOR 1ST EXPRESSION
	STAW	[CONST]		;(1) CONSTANT IN EQUATION

	MVI	A, 01		;SET TO DATA COLUMN
	STAW	[COLUMN]
	STAW	[Y1FLAG]		;+/-, ( )/(0.) FOR 1ST EXPRESSION
	STAW	[Y1PWR]		;1, 2, 3 POWER OF X FOR 1ST EXPRESSION
	STAW	[CONSTFLAG]	;+/- FLAG FOR CONSTANT

	LXI	HL, HEXDEF	;SETUP OUR DEFAULTS
	SHLD    [HEXADD]
	LXI	HL, PRGDEF
	SHLD    [PRGADD]
	LXI	HL, MUSDEF
	SHLD    [MUSADD]

	LXI	HL, MYMUSIC	;POINT TO ROM MUSIC
	LXI	DE, MUSDEF	;POINT TO RAM STORAGE
	MVI	B, $FF		;SHOULD BE $100 BYTES?
	CALT	B_CpHDxB	;COPY ROM TO RAM

	LXI	HL, MY_CODE	;POINT TO ROM EXAMPLE CODE
	LXI	DE, PRGDEF	;POINT TO RAM STORAGE
	MVI	B, $4B		;SHOULD BE $48+4 BYTES?
	CALT	B_CpHDxB	;COPY ROM TO RAM
	MVI	A, 08		;"RET" INSTRUCTION
	MOV     [PRGDEF+$F7], A	;COPY AT LEAST 1 AT THE END OF CODE.
	
	LXI	HL, NOTTXT	;POINT TO NOTEPAD TEXT IN ROM
	LXI	DE, NOTERAM	;POINT TO RAM DESTINATION
	MVI	B, $60		;96+1 BYTES
        CALT	B_CpHDxB	;COPY ROM TO RAM

	RET
;==============================================
;==============================================
TXSCROLL:    MVI		A, 00
	    MOV		[$C25D], A	;CLEAR THE BYTE USED ON SCREEN 2
	    OFFIW       [SINCNT], $0F	;CHECK IF IT'S ON EVERY 16TH LOOP
	    JR          RST_SINE
	    LXI		HL, SINE_TBL	;GET INITIAL SINE POS
	    SHLD        [SIN1POS]		;SAVE IT IN POINTER
;	    STAW	[SINCNT]		;RESET SINE COUNTER
RST_SINE:
	    LXI		DE, $C177	;THIS WILL SCROLL TEXT
	    LXI		HL, $C178	;IN LINE 5 OF THE DISPLAY
	    MVI		B, 73
	    CALT        B_CpHDxB	;(HL+)->(DE+)xB
;	    LDAW        [JOYP_CURR]
;	    MOV		[$C1C1], A	;PRINT JOYPAD DATA AS GRAPHICS
	    DCRW	[SCRLCOUNT]	;DECREMENT SROLL COUNT
	    JR		CPTXTSCROLL
NEXTTXT:                                 ;UPDATE THE TEXT POINTER, ETC
       	    MVI		A, 05            ;5->0 FOR EACH BYTE OF TEXT
	    STAW	[SCRLCOUNT]	;SCROLLER LOOP AMOUNT
	    LHLD        [TXTRAM]          ;POINT TO TEXT
	    LDAX	[HL+]		;GET A BYTE
;---------
	    EQI		A, $FF          ;HAVE WE REACHED THE END OF TEXT?
	    JR		SCRCONT
	    LXI		HL, MYTXT1	;POINT TO THE SCROLLER TEXT
            LDAX	[HL+]		;GET A BYTE
;----------
SCRCONT:
	    SHLD        [TXTRAM]          ;SAVE TO TEXT POINTER
	    ORI		A, $80		;SHIFT TEXT
	    MOV         [TXTBUF], A	;SAVE IT TO THE BUFFER
CPTXTSCROLL:
	    LDAW	[SCRLCOUNT]
	    NEI		A, 00		;IS SCROLL ZERO?  IF SO, PUT IN A BLANK!
	    JR		SCRMVSIN	;USE THAT ZERO AND STICK IT ONTO THE LCD!
     	    				;(ALSO CHANGE THE SINE WAVE)
	    STAW        [$FFCC]		;X-POS

	    LXI		HL, TXTBUF	;LOAD POINTER TO BUFFER
	    CALL	$FFCB		;JUMP TO OUR CODE IN *RAM*!!
	    MOV		A, [$C25D]	;COPY ONE SLICE TO THE SCROLLER
	    JR		SCRTOHERE	;USE THAT ZERO AND STICK IT ONTO THE LCD!
SCRMVSIN:
	    LHLD        [SIN1POS]		;GET SINE POINTER
            LDAX	[HL+]		;GET A BYTE
	    SHLD        [SIN1POS]		;ADVANCE SINE POINTER
	    STAW	[$FFCD]		;Y-POS!
	    INRW        [SINCNT]
	    NOP
	    MVI		A, 00
SCRTOHERE:
            MOV		[$C1C1], A
	    RET


; ****** THE CODE BELOW PUTS SOME BYTES IN RAM FOR LATER EXECUTION ****
; ****** THIS IS FOR THE PURPOSE OF MODIFYING THE TEXT PRINTING PARAMETERS ****
RAMCODE:
       MVI	A, $9B		;"CALT	B_PtText"
       STAW	[$FFCB]		;START OF 5 FREE BYTES IN RAM!
       MVI	A, 04		;
       STAW	[$FFCC]            ;X-POS
       MVI	A, $0C
       STAW	[$FFCD]            ;Y-POS
       MVI	A, $9C		;
       STAW	[$FFCE]            ;SPACING & PLACING
       MVI	A, 08		;"RET"
       STAW	[$FFCF]            ;
       RET
; *************************************



TIMER_START:
	 MVI	A, 01		;PLAY SOUND!??
	DB	$4D, $C9	;MOV TMM, A?
	 MVI	A, $FF
;	 STAW	[TMR_SPD]
	MOV	TM0, A
	STM
	EI
	   RET


MUS_PLAY:
;	LHLD    CURADD       	;LOAD FROM CURRENT ADDRESS!
	CALL	HXOFFSET	;POINT TO MUSIC DATA AT CURSOR!
	CALT    B_PlMusic
	RET

EXEC_CODE:
	CALT    B_ClScRam       ;CLEAR THE SCREEN
	CALT    B_WriteLCD	;WRITE LCD
	CALL	HXOFFSET	;POINT TO PRG DATA AT CURSOR!
	MOV	A, H
	MOV	B, A
	MOV	A, L
	MOV	C, A             ;TRANSFER ADDRESS OVER TO (BC)
	JB			;JUMP TO OUR CODE!
	RET			;JUST IN CASE?

;==============================================
JOY_ROUTINE:	;DO JOYSTICK LOGIC
      CALT	B_RdJoy		;READ JOYSTICK

      LDAW      [JOYP_STROBE]	;GET JOY STROBE
      MOV	B, A
      LDAW      [JOYP_CURR]	;GET JOY CURRENT
      ANA	A, B             ;FIX STROBE DATA!
      STAW      [JOYP_STROBE]
      LDAW      [JOYB_STROBE]	;GET JOY STROBE
      MOV	B, A
      LDAW      [JOYB_CURR]	;GET JOY CURRENT
      ANA	A, B             ;FIX STROBE DATA!
      STAW      [JOYB_STROBE]

;	CLC
;	RAR			;DIVIDE A BY 2
;	MOV	B, A
;	LDAW    [JOYP_STROBE]
;	ORA	A, B
;	MOV	B, A		;PITCH GOES HERE
;	MVI	A, 01		;LENGTH
;	CALL	$0197		;JUMP TO *BIOS* SOUND ROUTINE!
      RET

DEMO_LOGIC:
	  LXI	HL, DEMJMP_TABLE	;LOAD THE JUMP TABLE
	  LDAW	[TST_MODE]	;GET MODE VALUE
	  CLC			;(IS THIS NECESSARY?)
   	  RAL			;MULTIPLY BY 2
   	  MOV	E, A
   	  CALT	B_HPlE		;ADD E
   	  LDAX	[HL+]
   	  MOV	C, A
   	  LDAX	[HL]
   	  MOV	B, A             ;GET POINTER, PUT IN BC
   	  JB			;JUMP TO TABLE POSITION
   	  RET			;(JUST IN CASE...)


DEMJMP_TABLE:			;A TABLE OF THE DEMO MODES
      DW        MODE0ROUTINE, MODE1ROUTINE, MODE2ROUTINE, MODE3ROUTINE
      DW	MODE4ROUTINE, MODE5ROUTINE, MODE6ROUTINE, MODE7ROUTINE
      DW	MODE8ROUTINE, MODE9ROUTINE, MODEAROUTINE, MODEBROUTINE
      DW	MODECROUTINE

SETPJMP_TABLE:			;A TABLE FOR DEMO SETUP ROUTINES
      DW        DEM1SETUP, DEM2SETUP, DEM3SETUP, DEM4SETUP, DEM5SETUP
      DW	DEM6SETUP, DEM7SETUP, MODE0SETUP, MODE0SETUP, MODE0SETUP
;==============================================
WRCORNERS:	;DRAWS SOME DOTS IN THE CORNERS OF THE MENU SCREEN
	MVI	A, $03
	MOV	[$C000], A
	MOV	[$C04A], A
	MVI	A, $01
	MOV	[$C001], A
	MOV	[$C049], A
	MVI	A, $C0
	MOV	[$C257], A
	MOV	[$C20D], A
	MVI	A, $80
	MOV	[$C256], A
	MOV	[$C20E], A
	RET

WRTMENU:		;DISPLAYS THE MAIN MENU TEXT

       LXI	HL, TXT_MENU
       CALT	B_PtText	;PRINT TEXT
       DB	05, 00, $9B	;PLACES HEADER AT TOP
       LXI	BC, $0008	;SET SCREEN POINTER
       CALT	B_ScrPosBC
       CALT     B_DrwLine	;DRAW ONE LINE
       DB       $01, $4A	;PATTERN, LENGTH

       CALL	RAMCODE

       MVI	A, 00
	STAW	[CURSX]		;SETUP MENU CURSOR POSITION

       LXI	HL, TXT_01
       MVI	C, $07	;A LOOP COUNTER

WRLOP1:
       PUSH	BC
       PUSH	HL
       CALL	$FFCB		;JUMP TO OUR CODE IN *RAM*!!
       POP	HL
       POP	BC
       MVI	E, $0C		;ADD POINTER
       CALT     B_HPlE		;ADD E
	LDAW	[$FFCD]
	ADI	A, $06		;ADD A VALUE...
        STAW	[$FFCD]		;TO THE Y-POS
        DCR	C
        JR	WRLOP1

        CALL	DRMENCURS	;DRAW MENU CURSOR

       RET


CLMENCURS:		;CLEARS THE POINTER AT THE MENU POS
	 LXI	HL, TXT_SPC1
DRMENCURS:               ;DRAWS THE POINTER AT THE MENU POS
	 LXI	HL, TXT_CURS1
	 LDAW	[CURSX]
	 STAW   [$FFCC]            ;X-POS
	 LDAW	[CURSY]
	 CALL	MULT6

	 ADI	A, $0C		;ADD OFFSET
	 STAW	[$FFCD]            ;Y-POS
	 MVI	A, $91		;
	 STAW	[$FFCE]            ;SPACING & PLACING
	 CALL	$FFCB		;JUMP TO OUR CODE IN *RAM*!!
	 RET
;====================================================================

M3RESULTS:	;SAVES REGISTER CONTENTS AND DISPLAYS THEM AFTER CODE EXECUTION
	MOV     [PRGDEF+$F8], A
	MOV     [PRGDEF+$F9], B
	MOV     [PRGDEF+$FA], C
	MOV     [PRGDEF+$FB], D
	MOV     [PRGDEF+$FC], E
	MOV     [PRGDEF+$FD], H
	MOV     [PRGDEF+$FE], L
	
        CALT	B_CpS0		;COPY SCREEN 0 FOR SAFE-KEEPING

	LXI     HL, PRGRES_TEXT
        CALT	B_PtText	;PRINT TEXT
        DB	00, $34, $8F	;PLACES TEXT DOWN LOW

        LXI	HL, PRGDEF+$F8
	CALT    B_PtByte
	DB	00, $3A, $CD	;PRINTS A, B, C CONTENTS

        LXI	HL, PRGDEF+$FB
	CALT    B_PtByte
	DB	$1E, $3A, $CF	;PRINTS D, E, H, L CONTENTS
	MVI	A, $00
   	STAX	[DE+]
   	STAX	[DE+]
   	STAX	[DE+]
   	STAX	[DE+]
   	STAX	[DE+]

  	CALT	B_WriteLCD    	;1ST SCREEN TO LCD
	RET

;==============================================
MULT6:   ;MULTIPLIES A BY 6 (& CLOBBERS E)
         CLC			;(IS THIS NECESSARY?)
	 RAL			;MULTIPLY BY 2
	 MOV	E, A
         CLC			;(IS THIS NECESSARY?)
	 RAL			;MULTIPLY BY 4
	 ADD	A, E		;MULTIPLY BY 6
	RET
;==============================================
SPR_CLEAR:	LXI	HL, MARSPR	;LOAD THE ADDRESS OF "STANDING MARIO"
	MOV	A, [FACOLD]                ;GET OUR OLD SPRITE ADDRESS
	JR	UPD_SPR

SPR_DRAW:	LXI	HL, MARSPR	;LOAD THE ADDRESS OF "STANDING MARIO"
	MOV	A, [FACING]                ;GET OUR CURRENT SPRITE
	MOV     [FACOLD], A                ;SAVE IT IN THE OLD POINTER
UPD_SPR:
	CLC
	RAR
	RAR
	RAR
	RAR	;MULTIPLY BY 32
	MOV	L, A			;CHEAT AND PUT IT STRAIGHT IN L


	LXI	DE, SPRDEST	;MIDDLE OF SCREEN 1, BOTTOM LINE
	MVI	B, 11		;COPY 12 BYTES
SPLP01:
	LDAX	[HL+]		;GET SPRITE DEF
	XRAX	[DE]		;XOR WITH SCREEN DATA
	STAX	[DE+]              ;SAVE IT
	DCR	B
	JR      SPLP01
	LXI	DE, SPRDEST-75	;MIDDLE OF SCREEN 1, TOP LINE

	MVI	B, 11		;COPY 12 BYTES
SPLP02:
	LDAX	[HL+]		;GET SPRITE DEF
	XRAX	[DE]		;XOR WITH SCREEN DATA
	STAX	[DE+]              ;SAVE IT
	DCR	B
	JR      SPLP02
	RET

;====================================================================
;====================================================================
SCRO_L:		;THESE ROUTINES SCROLL THE SCREENS (AND REDRAW MARIO?)

	LXI	HL, $C257		;OUR 2ND DESTINATION/SOURCE...
	SHLD    [ADDRT1]			;STORE IT FOR LATER.

	LXI	DE, $C4AF		;DESTINATION WILL BE 75, 64
	LXI	HL, $C4AE		;SOURCE WILL BE 1 BYTE OVER

	MVI	A, 06			;7 LINES OF THIS LOOP
	STAW	[LOOPCNT]
SCRLLP:
	LDAX    [DE]			;GET OUR 1ST BYTE
	PUSH	VA			;STORE IT FOR A WHILE
	MVI	B, 73			;THIS SHOULD DO IT 74 ($4A)TIMES!
	CALT    B_CmHDxB		;COPY H- ->D- xB
		;WE SHOULD NOW HAVE:	DE=$C465, HL=$C464 ADDRT1=$C257
	SHLD	[ADDRT2]			;ADDRT2=$C464
	LHLD	[ADDRT1]			;HL=$C257
	LDAX	[HL-]			;GET ONE BYTE FROM $C257, HL=$C256
	STAX	[DE]			;SAVE IN $C465
	LDED	[ADDRT1]			;DE=$C257
	MVI	B, 73			;THIS SHOULD DO IT 74 ($4A)TIMES!
	CALT    B_CmHDxB		;COPY H- ->D- xB
		;WE SHOULD NOW HAVE:	DE=$C20D, HL=$C20C
	SHLD	[ADDRT1]			;ADDRT1=$C20C, READY FOR NEXT LOOP
	POP	VA			;GET OUR ONE BYTE AGAIN
	STAX	[DE]			;SAVE IT INTO $C2A2
	
	LDED	[ADDRT2]                  ;DE=$C464, READY FOR NEXT LOOP
	LHLD	[ADDRT2]			;HL=$C464
	DCX	HL			;HL=$C463, READY FOR NEXT LOOP
	
	DCRW	[LOOPCNT]
	JRE     SCRLLP			;JUMP FOR THE NEXT LOOP

	JMP	SCRO_COMM

SCRO_R:
;	LXI	HL, $C258		;OUR 2ND DESTINATION/SOURCE...
;	SHLD    [ADDRT1]			;STORE IT FOR LATER.
;
;	LXI	DE, $C000		;DESTINATION WILL BE 0, 0
;	LXI	HL, $C001		;SOURCE WILL BE 1 BYTE OVER


	LXI	HL, $C2A3		;OUR 2ND DESTINATION/SOURCE...
	SHLD    [ADDRT1]			;STORE IT FOR LATER.

	LXI	DE, $C04B		;DESTINATION WILL BE 0, 8 (DON'T SCROLL STATUS BAR)
	LXI	HL, $C04C		;SOURCE WILL BE 1 BYTE OVER

	MVI	A, 06			;7 LINES OF THIS LOOP
	STAW	[LOOPCNT]
SCRRLP:
	LDAX    [DE]			;GET OUR 1ST BYTE
	PUSH	VA			;STORE IT FOR A WHILE
	MVI	B, 73			;THIS SHOULD DO IT 74 ($4A)TIMES!
	CALT    B_CpHDxB		;COPY H->D xB
		;WE SHOULD NOW HAVE:	DE=$C04A, HL=$C04B ADDRT1=$C258
	SHLD	[ADDRT2]			;ADDRT2=$C04B
	LHLD	[ADDRT1]			;HL=$C258
	LDAX	[HL+]			;GET ONE BYTE FROM $C258, HL=$C259
	STAX	[DE]			;SAVE IN $C04A
	LDED	[ADDRT1]			;DE=$C258
	MVI	B, 73			;THIS SHOULD DO IT 74 ($4A)TIMES!
	CALT    B_CpHDxB		;COPY H->D xB
		;WE SHOULD NOW HAVE:	DE=$C2A2, HL=$C2A3
	SHLD	[ADDRT1]			;ADDRT1=$C2A3, READY FOR NEXT LOOP
	POP	VA			;GET OUR ONE BYTE AGAIN
	STAX	[DE]			;SAVE IT INTO $C2A2
	
	LDED	[ADDRT2]                  ;DE=$C04B, READY FOR NEXT LOOP
	LHLD	[ADDRT2]			;HL=$C04B
	INX	HL			;HL=$C04C, READY FOR NEXT LOOP
	
	DCRW	[LOOPCNT]
	JRE     SCRRLP			;JUMP FOR THE NEXT LOOP

	JR	SCRO_COMM
	

SCRO_COMM:	;THE COMMON ROUTINE FOR BOTH
        CALL	SPR_DRAW	;DRAW OUR NEW SPRITE
	CALT	B_WriteLCD    	;1ST SCREEN TO LCD
	RET

;====================================================================
;====================================================================

RLE_DECODE:
;DOES A SIMPLE RLE DECODING OF DATA POINTED TO BY (HL).
;DESTINATION IN (DE) GETS WRITTEN TO.
;DATA FORMAT: 	BYTE 0: STOP CODE (CAN BE ANY VALUE) TO MARK THE END OF THE DATA (& EXIT ROUTINE)
;               BYTE 1: RLE CODE (..ANY OTHER VALUE) FOR A RLE COUNT
;		BYTE 2+ DATA, EITHER LITERAL OR A RLE COUNT (3 BYTES: RLE CODE, COUNT, VALUE)
;		...
;		BYTE X: STOP MARKER (AGAIN)
;----------------------
	LDAX	[HL+]              ;GET OUR RLE STOP CODE FIRST
	STAW	[RLESTOP]
	MOV	C, A		;MOVE OUR STOP MARKER TO C FOR COMPARISON
	LDAX	[HL+]       	;THEN GET OUR RLE LOOP CODE
	STAW	[RLEMARKER]       ;(WE DON'T REALLY NEED THIS SAVED ANYWHERE...)
	MOV	B, A		;MOVE OUR MARKER TO B FOR COMPARISON
RLE_START:
	LDAX	[HL+]              ;GET A BYTE
	NEA	A, C             ;CHECK IF SAME AS STOP MARKER
	JRE     RLE_END         ;WE'RE FINISHED
	EQA	A, B             ;IS IT THE RLE MARKER?
	JR	RL_WRITE        ;IF NOT, WRITE ONCE.
;--------
	;IF RLE MARKER, READ COUNTER...
	LDAX	[HL+]
	MOV	C, A
	DCR	C               ;OFF-BY-1 ERROR?
	NOP
	;AND READ VALUE TO REPEAT...
	LDAX	[HL+]
RL_WR2:
	STAX	[DE+]		;WRITE OUR BYTE.
	DCR	C		;DECREMENT OUR COUNTER
	JR      RL_WR2          ;LOOP UNTIL A CARRY

	LDAW	[RLESTOP]         ;RELOAD OUR STOP MARKER
	MOV	C, A
	JR	RLE_START
;------------
RL_WRITE:
	STAX	[DE+]
	JR      RLE_START
RLE_END:
	RET
;==============================================
;==============================================

CPY_MY_GFX:
;COPIES MY GRAPHIC TILES TO THE SCREEN IN A LAYOUT THAT I CAN ACTUALLY USE!
;IN: HL = SOURCE, DE = DESTINATION, B = WIDTH (PIXELS), C = HEIGHT (LINES)
     	  PUSH	HL	;SAVE SOURCE & DESTINATION
     	  PUSH	DE
     	  PUSH	BC	;SAVE COUNTER
	  CALT	B_CpHDxB	;COPY (HL)->(DE)xB
	  POP	BC	;RESTORE COUNTER
	  POP   HL       ;RESTORE (D)ESTINATION
	  LXI	DE, $FFB5	;NEGATIVE 75 IN HEX!
	  CALT	B_HPlDE		;ADD(!) TO HL
;	  MVI	E, 75   ;DESTINATION GETS ANOTHER 75 BYTES...
;	  CALT	B_HPlE  ;ADD E
	  POP	DE       ;RESTORE (H)SOURCE
          CALT	B_XChgHLDE	;XCHANGE HL, DE
          PUSH	DE
          MVI	E, $80	;SOURCE GETS ANOTHER 128 BYTES...
          CALT	B_HPlE  ;ADD E
          POP	DE
          DCR	C
          JR	CPY_MY_GFX	;LOOP C TIMES
	  RET

;==============================================
;==============================================
LCD2_RAM_WRITE:		;COPIES FROM THE 2ND SCREEN TO THE LCD!
LCD2A_RAM_WRITE:
;--------- LCD DRIVER 1 ON...
	ORI     PA, $08
	LXI     HL, $C289
	LXI     DE, $007D
	MVI     B, $00
LCLP20:	ANI     PA, $FB
	MOV     A, B
	MOV     PB, A
	ORI     PA, $02
	ANI     PA, $FD
	MVI     C, $31
	ORI     PA, $04
LCLP21: 	LDAX    [HL-]
	MOV     PB, A
	ORI     PA, $02
	ANI     PA, $FD
	DCR     C
	JR      LCLP21
	CALT    $0096		;ADD DE
	MOV     A, B
	ADINC   A, $40
	JR      LCLPY1
	MOV     B, A
	JRE     LCLP20
LCLPY1: 	ANI     PA, $F7
;	RET
;--------- LCD DRIVER 2 ON...
LCD2B_RAM_WRITE:
	ORI     PA, $10
	LXI     HL, $C384
	LXI     DE, $0019
	MVI     B, $00
LCLP22: 	ANI     PA, $FB
	MOV     A, B
	MOV     PB, A
	ORI     PA, $02
	ANI     PA, $FD
	MVI     C, $31
	ORI     PA, $04
LCLP23: 	LDAX    [HL+]
	MOV     PB, A
	ORI     PA, $02
	ANI     PA, $FD
	DCR     C
	JR      LCLP23
	CALT    $0096		;ADD DE
	MOV     A, B
	ADINC   A, $40
	JR      LCLPY2
	MOV     B, A
	JRE     LCLP22
LCLPY2: 	CALT    $008A		;CLEAR A
	STAW    [$FF96]
	ANI     PA, $EF
;	RET
;--------- LCD DRIVER 3 ON...
LCD2C_RAM_WRITE:
	ORI     PA, $20
	LXI     HL, $C28A ;LOAD MY OWN SCREEN DATA
	LXI     DE, $C3B6
	JMP	$023F	;RESUME IN BIOS ROUTINE
;==============================================
MULHL8:		;MULTIPLY Ax8, ADD TO HL
	CLC
	MVI		D, 00
	RAL
	MOV		E, A
	MOV		A, D
	RAL
	MOV             D, A
	MOV		A, E
	RAL
	MOV		E, A
	MOV		A, D
	RAL
	MOV             D, A
	MOV		A, E
	RAL
	MOV		E, A
	MOV		A, D
	RAL
	MOV             D, A		;ALL THIS TO MULTIPLY A BY 8!!???

	CALT            B_HPlDE		;ADD OUR OFFSET
	RET

;==============================================
;==============================================
MY_CODE:		;EXAMPLE CODE FOR THE PRG EXECUTOR!
        LXI	HL, MYCDTXT-MY_CODE+PRGDEF       ;POINT TO "HELLO WORLD"
       CALT	B_PtText	;PRINT TEXT
       DB	03, $1C, $9C	;PLACES TEXT ON-SCREEN
       CALT	B_ScInvert
	NOP
       NOP
       NOP
	RET
MYCDTXT:
	DB	"H"-$20, "E"-$20, "L"-$20, "L"-$20, "O"-$20, ","-$20
        DB	"W"-$20, "O"-$20, "R"-$20, "L"-$20, "D"-$20, "!"-$20
MYCOD2:	;A SECOND PROGRAM...
	NOP
	NOP
	NOP
	NOP
	MVI	A, $55	;AN ARBITRARY NUMBER
	NOP
	NOP
	
	NOP
	NOP
	NOP
	NOP
	LXI	HL, $AABB
	NOP
	
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	RET

MYCOD3:
        CALT	B_RdJoy		;READ JOYSTICK
        OFFIW	[JOYB_CURR], $01		;IS "SELECT" PRESSED?
        RET		;IF SO, END

        LDAW	[JOYB_CURR]
	MOV	[$C12C], A        ;4TH ROW, RIGHT AT THE START...

        LXI	HL, $C0E2		;3RD ROW DOWN ON LCD
        LXI	DE, $C0E1
        MVI	B, 149		;2x75 BYTES
        CALT    B_CpHDxB

        LDAW	[JOYP_CURR]
     	MOV	[$C176], A        ;4TH ROW, RIGHT AT THE END...

	CALT	B_WriteLCD    ;UPDATE SCREEN
        JR	MYCOD3


;==============================================
;==============================================
INTERRUPT:
	 DI
	 INRW      [VB2_COUNT]
	 JR	   NOINCVB
	 INRW	   [VB_PASS]
         NOP
NOINCVB:	 JMP       $0128		;RETURN CONTROL TO SYSTEM??

;==============================================
;16-BIT * 16-BIT -> 32-BIT MULTIPLY ROUTINE
;TAKEN FROM A 6502 EXAMPLE, NATURALLY!
;ACC*AUX -> [ACC, EXT] (low, hi) 32 bit result

MULT16:
          MVI	A, 0		;LDA #0
          STAW 	[EXT+1]		;STA EXT+1
          MOV	C, A		;(STORE OUR #0 AGAIN)
          MVI 	B, $10		;LDY #$11
	  CLC			;CLC
M16LP:     LDAW	[EXT+1]		;ROR EXT+1
	  RAR
	  STAW	[EXT+1]
          MOV	A, C		;ROR
          RAR
          MOV	C, A
          LDAW	[ACC+1]		;ROR ACC+1
          RAR
          STAW	[ACC+1]
          LDAW	[ACC]		;ROR ACC
          RAR
          STAW	[ACC]
          SKNC			;BCC M162
          JR	M16NX
          JR	M162
M16NX:	  CLC			;CLC
          LDAW	[AUX]		;ADC AUX
	  ADC	A, C
	  PUSH	VA		;PHA
          LDAW	[AUX+1]		;LDA AUX+1
          MOV	C, A
          LDAW	[EXT+1]		;ADC EXT+1
          ADC	A, C
          STAW	[EXT+1]		;STA EXT+1
          POP	VA		;PLA
          MOV	C, A
M162:      DCR	B		;DEY
          JRE	M16LP		;BNE M16LP
          MOV	A, C             ;STA EXT
          STAW	[EXT]
          RET			;RTS



;==============================================













;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
OPE0FF:		;MANAGE OPCODE E0-FF (BRANCH NEGATIVE)
	MOV	E, A		;MOVE IT DIRECTLY INTO E
	MVI	D, $FF		;MOVE THE NEGATIVE SIGN INTO D
	CALT    B_HPlDE		;ADD OUR OFFSET
OPC0FF:
	SHLD    [ADDRT2]		;SAVE HL IN A TEMP VARIABLE
	LXI	DE, INSTEXT	;POINT TO OUR INSTRUCTION TEXT
	LXI	HL, E0FFTXT	;POINT TO THIS ONE TEXT
	MVI	B, 02		;COPY 3 BYTES
	CALT    B_CpHDxB	;COPY FROM H TO D
	LXI	HL, ADDRT2	;POINT TO THAT TEMP VARIABLE

	CALL	DECM4A		;PRINT A WORD
	JMP	LNYBCOMMAND	;PRINT OUR INSTRUCTION & WE'RE FINISHED.
E0FFTXT:	DB "J"+$80, "R"+$80, " "+$80

OPC0DF:		;MANAGE OPCODE C0-DF (BRANCH FORWARD)
	SBI	A, $C0		;TAKE OFF THE OPCODE
	MOV	E, A
	CALT	B_HPlE		;ADD OUR OFFSET
	JR	OPC0FF		;CONTINUE AT OUR EXISTING CODE

OP80BF:          ;MANAGE CALT TABLES...
	SBI	A, $80		;TAKE OFF THE OPCODE
	PUSH	VA
	LXI	DE, INSTEXT	;POINT TO OUR INSTRUCTION TEXT
	LXI	HL, BF80TXT	;POINT TO THIS CALT TEXT
	MVI	B, 04		;COPY 5 BYTES
	CALT    B_CpHDxB	;COPY FROM H TO D
	POP	VA

	PUSH		HL
	LXI		HL, CALTBL	;POINT TO OUR CALL TABLE
	PUSH		DE
	CALL            MULHL8		;MULTIPLY Ax8, ADD TO HL
	POP		DE
	MVI	A, 00	;"NO COMMAND"
	JMP	INMV01
BF80TXT:	DB "C"+$80, "A"+$80, "L"+$80, "T"+$80, " "+$80

OP787F:
	PUSH	VA
	PUSH	HL
	LXI	DE, INSTEXT	;POINT TO OUR INSTRUCTION TEXT
	LXI	HL, S87FTXT	;POINT TO THIS CALF TEXT
	MVI	B, 04		;COPY 5 BYTES
	CALT    B_CpHDxB	;COPY FROM H TO D
	POP	HL
	POP	VA
	ANI	A, $0F		;ISOLATE LOWER NYBBLE
	ADI	A, $40		;SHIFT TO HEX TEXT
	STAX	[DE+]
	CALL    DEBYTPRINT	;PRINT THE NEXT BYTE AS HEX
	JMP     LNYBCOMMAND	;COPY THE TEXT TO SCREEN AND WE'RE DONE!
S87FTXT:	DB "C"+$80, "A"+$80, "L"+$80, "F"+$80, " "+$80

OP4F:	LDAX	[HL+]		;GET OPERAND, MOVE ON
	MOV	E, A		;MOVE IT DIRECTLY INTO E
	MVI	D, $FF		;MOVE THE NEGATIVE SIGN INTO D
	CALT    B_HPlDE		;ADD OUR OFFSET
OP4EF:
	SHLD    [ADDRT2]		;SAVE HL IN A TEMP VARIABLE
	LXI	DE, INSTEXT	;POINT TO OUR INSTRUCTION TEXT
	LXI	HL, O4FTXT	;POINT TO THIS ONE TEXT
	MVI	B, 03		;COPY 4 BYTES
	CALT    B_CpHDxB	;COPY FROM H TO D
	LXI	HL, ADDRT2	;POINT TO THAT TEMP VARIABLE

	CALL	DECM4A		;PRINT A WORD
	JMP	LNYBCOMMAND	;PRINT OUR INSTRUCTION & WE'RE FINISHED.
O4FTXT:	DB "J"+$80, "R"+$80, "E"+$80, " "+$80
OP4E:
	LDAX	[HL+]
	MOV	E, A
	CALT	B_HPlE		;ADD OUR OFFSET
	JR	OP4EF		;CONTINUE AT OUR EXISTING CODE
	
OP48:
	LDAX	[HL+]              ;READ NEXT OPCODE
	SBI	A, $0E		;SHIFT THE OPCODE DOWN
	LTI	A, $32		;IS IT $00-$31?
	JMP     ILLEGAL		;IF NOT, IT'S ILLEGAL
	PUSH	HL
	LXI	HL, OPTB48	;POINT TO OUR 48xx OPCODE TABLE
	JMP     DECML8
OP64:
	LDAX		[HL+]	;READ NEXT OPCODE
	STAW		[INST1]
	ANI		A, $78	;REMOVE 7th, 2nd, 1st, 0th DIGITS
	MOV		E, A
	PUSH		HL
	LXI		HL, OPTB64	;POINT TO OUR 64xx OPCODE TABLE
	CALT    	B_HPlE		;ADD OUR OFFSET
	LXI		DE, INSTEXT	;POINT TO OUR INSTRUCTION TEXT
	LDAW		[INST1]	;GET INSTRUCTION AGAIN
	ONI		A, $80	;IS IT ONE OF THE FEW HIGH BYTES?
	JRE		INMV00
	ANI		A, $AC	;FILTER OUT: 10101100
	EQI		A, $88	;WE WANT:    1X0X10XX
	JMP		ILLEGAL	;IF NOT WHAT WE WANT, REJECT.
;SO NOW, IT DEFINITELY SHOULD BE 64 88-8B, 98-9B, C8-CB, D8-DB.
	ANIW		[INST1], $F7	;REMOVE BIT 4 HERE...
	LDAX		[HL+]	;GET DUMMY BYTE
	MVI		A, $72	;"Ex BYTE 3", "BYTE"
        JRE		INMV01

OP60:
	LDAX		[HL+]	;READ NEXT OPCODE
	STAW		[INST1]
	ANI		A, $78	;REMOVE 7th, 2nd, 1st, 0th DIGITS
	MOV		E, A
	PUSH		HL
	LXI		HL, OPTB60	;POINT TO OUR 60xx OPCODE TABLE
	CALT    	B_HPlE		;ADD OUR OFFSET
	LXI		DE, INSTEXT	;POINT TO OUR INSTRUCTION TEXT
	LDAX		[HL+]		;GET OUR COMMAND CODE FIRST
	NEI		A, $F0		;IS IT F0 (INVALID?)
	JRE		INMV01
	OFFIW		[INST1], $80	;IS THE TOP NYBBLE OF OUR FIRST OPCODE 80?
	MVI		A, $15		;REPLACE THE COMMAND WITH THE OTHER SET (V, A->A, V)
	JRE		INMV01

OP70:
	LDAX		[HL+]	;READ NEXT OPCODE
	STAW		[INST1]
	ONI		A, $80	;IS IT $80-$FF?
	JR		OP70V1	;TRY OTHERS...
	ANI		A, $78	;REMOVE THE BITS WE DON'T NEED
	MOV		E, A
	PUSH		HL
	LXI		HL, OPTB70	;POINT TO OUR 70xx OPCODE TABLE
	CALT    	B_HPlE		;ADD OUR OFFSET
	LXI		DE, INSTEXT	;POINT TO OUR INSTRUCTION TEXT
	LDAX		[HL+]		;GET OUR COMMAND CODE
	JRE		INMV01
OP70V1:
	ANI		A, $68
	EQI		A, $68	;WE'RE TESTING X11X1000
	JR		OP70V2
	PUSH		HL
	LXI		HL, EX7068B	;POINT TO "MOV"
	LXI		DE, INSTEXT	;POINT TO OUR INSTRUCTION TEXT
	ONIW		[INST1], $10	;CHECK IF 6X OR 7X
	MVI		A, $54		;Ex1, word IF 6X
	MVI		A, $45		;word, Ex1 IF 7X
	JRE		INMV01		;CONTINUE TO WRITE
OP70V2:
	LDAW		[INST1]
	ANI		A, $CE		;MASK OUT 11XX 111X
	EQI		A, $0E		;TEST FOR 0000 1110
	JRE		ILLEGAL
;NOW IT'S DEFINITELY 0E, 0F, 1E, 1F, 2E, 2F, 3E, 3F.
	LDAW		[INST1]
	RAL
	RAL
	RAL
	ANI		A, $08	;ISOLATE LOWEST BIT
	MOV		B, A
	LDAW		[INST1]
	ANI		A, $30	;ISOLATE BITS 4, 5
	ORA		A, B
;        LXI		HL, OPT70E
;OPT70E		EQU $6C40	;OPCODE TABLE FOR 70:0E, 0F, 1E, 1F, 2E, 2F, 3E, 3F
	ADI		A, $40	;LOW NYBBLE OF THE ABOVE POINTER
	PUSH		HL
	MOV		L, A
	MVI		H, $6C	;HIGH NYBBLE
	LXI		DE, INSTEXT	;POINT TO OUR INSTRUCTION TEXT
	LDAX		[HL+]		;GET OUR COMMAND CODE FIRST
	JRE		INMV01

OP4C:	MVI		A, $17	;MOV A, PORT
OP4D:	MVI		A, $71	;MOV PORT, A
	STAW		[INST4]	;SAVE COMMAND
	LDAX		[HL+]      ;GET NEXT INSTRUCTION
	STAW		[INST1]   ;SAVE IT
	SBI		A, $C0	;SHIFT DOWN TO OUR 9 OPCODES
	LTI		A, $0A		;IS IT $00-$09?
	JMP     	ILLEGAL		;IF NOT, IT'S ILLEGAL
	PUSH		HL
	LXI		HL, EX7068B	;POINT TO OUR "MOV" INSTRUCTION
	LXI		DE, INSTEXT	;POINT TO OUR INSTRUCTION TEXT
	JRE     	INMV02
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;DECINSTRUCTION		IF IN PRG. EDITOR MODE, PRINT THE INSTRUCTION MNEMONIC
;			(THIS COULD TAKE SOME TIME...)
DECINSTRUCTION:
	EQIW		[TST_MODE], 03	;ARE WE IN THE PRG EDITOR OR NOT?
	JRE		NODECODE
;-------------
	LXI		DE, INSTEXT	;POINT TO OUR INSTRUCTION TEXT
	MVI		B, 12		;13 BYTES
	MVI		A, 00            ;CLEAR OUR TEXT STRING!
INCLRLOOP:
	STAX		[DE+]
	DCR		B
	JR              INCLRLOOP
;-----------------
	CALL		HXOFFSET	;GET THE BYTE WE'RE POINTING TO
	STAW		[INST1]
	INX		HL
;TESTS TESTS TESTS TESTS TESTS TESTS TESTS TESTS 
	LTI		A, $E0		;IS IT $E0-$FF? (JR-)
	JMP		OPE0FF
	LTI		A, $C0		;IS IT $C0-$DF? (JR+)
	JMP		OPC0DF
	LTI		A, $80		;IS IT $80-$BF? (CALT)
	JMP		OP80BF
	LTI		A, $78          ;IS IT $78-$7F? (CALF)
	JMP		OP787F
        NEI		A, $70		;IS IT 70xx?
	JMP		OP70
	NEI		A, $64		;IS IT 64xx?
	JMP		OP64
	NEI		A, $60		;IS IT 60xx?
	JMP		OP60
	NEI		A, $4F		;IS IT $4F? (JRE-)
	JMP		OP4F
	NEI		A, $4E		;IS IT $4E? (JRE+)
	JMP		OP4E
	NEI		A, $4D		;IS IT $4Dxx? (MOV PORTS)
	JMP		OP4D
	NEI		A, $4C		;IS IT $4Cxx? (MOV PORTS)
	JMP		OP4C
	NEI		A, $48		;IS IT 48xx?
	JMP		OP48



;TESTS TESTS TESTS TESTS TESTS TESTS TESTS TESTS
	PUSH		HL
	LXI		HL, OPTBL1	;POINT TO OUR OPCODE TABLE
DECML8:
	CALL            MULHL8		;MULTIPLY Ax8, ADD TO HL

	LXI		DE, INSTEXT	;POINT TO OUR INSTRUCTION TEXT
INMV00:  LDAX		[HL+]		;GET OUR COMMAND CODE FIRST
INMV01:  STAW		[INST4]
INMV02:  MVI		B, 06		;7 BYTES
INMOVLOOP:
	LDAX		[HL+]
	NEI		A, $00		;SKIP IF NOT ZERO...
	JR		TERMINATE       ;IF ZERO (TERMINATOR, EXIT)
	ADI		A, $80		;POINT TO OUR FONT
	STAX		[DE+]
	DCR		B
	JR              INMOVLOOP
TERMINATE:
	POP		HL
;----------------------- GET HIGH NYBBLE COMMAND
	LDAW		[INST4]
	RAR
	RAR
	RAR
	RAR
	ANI		A, $0F	;ISOLATE TOP NYBBLE
	SKNZ
	JR		HNYBCOMMAND    ;IF ZERO, DO NOTHING...

	CALL		DECCOMMAND
HNYBCOMMAND:
;----------------------- GET LOW NYBBLE COMMAND
	LDAW		[INST4]
	ANI		A, $0F	;ISOLATE BOTTOM NYBBLE
	SKNZ
	JR		LNYBCOMMAND	;IF THE 2ND COMMAND IS ZERO, DON'T DO ANYTHING
	PUSH		VA
	MVI		A, $AC		;"COMMA" CHARACTER
	STAX		[DE+]		;SAVE IT IN OUR OUTPUT STRING
	POP		VA
	CALL		DECCOMMAND      ;IF NON-ZERO, ADD A COMMA AND DECODE THE COMMAND
LNYBCOMMAND:
;-----------------------
        LXI	HL, INSTEXT	;OUR INSTRUCTION STORAGE IN RAM
PRTINST:				;PRINT OUR INSTRUCTION STRING, THEN!
	CALT	B_PtText	;PRINT TEXT
        DB	00, 59, $9D	;PLACES TEXT AT BOTTOM
NODECODE:
	RET

ILLEGAL:		;FOR ILLEGAL INSTRUCTIONS
	LXI	HL, ILLTEXT
	JR	PRTINST
ILLTEXT:
	DB	0, "<"+$80, "I"+$80, "n"+$80, "v"+$80, "a"+$80, "l"+$80, "i"+$80, "d"+$80, "."+$80, ">"+$80
	DB	0, 0
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DECCOMMAND:
	EQI	A, $00           ;IS IT 0? (NOTHING)
	JR	DECMD0
	JMP	DECMEND
DECMD0:
	EQI	A, $0F           ;IS IT ILLEGAL?
	JR	DECMD1
	POP	HL		;DISCARD RETURN ADDRESS!
	JR	ILLEGAL
DECMD1:
	EQI	A, 01		;IS IT "PRINT A"?
	JR	DECMD2		;IF NOT, TRY NEXT COMMAND
	MVI	A, "A"+$80
	STAX	[DE+]		;INSER THE CHARACTER A
	JRE      DECMEND
DECMD2:
	EQI	A, 02		;IS IT A BYTE TO PRINT?
	JR	DECMD4
DEBYTPRINT:
	LDAX	[HL]               ;GET OUR OPERAND
	RAR
	RAR
	RAR
	RAR
	ANI	A, $0F		;GET HIGH NYBBLE
	ADI	A, $40		;SHIFT TO HEX TEXT
	STAX	[DE+]
	LDAX	[HL+]              ;GET OPERAND AGAIN
	ANI	A, $0F		;GET LOW NYBBLE
	ADI	A, $40		;SHIFT TO HEX TEXT
	STAX	[DE+]
	JRE      DECMEND
DECMD4:
	EQI	A, 04		;IS IT A WORD TO PRINT?
	JR	DECMD5
DECM4A:
	INX	HL		;GET HIGH BYTE FIRST!
	LDAX	[HL]               ;GET OUR OPERAND
	RAR
	RAR
	RAR
	RAR
	ANI	A, $0F		;GET HIGH NYBBLE
	ADI	A, $40		;SHIFT TO HEX TEXT
	STAX	[DE+]
	LDAX	[HL-]              ;GET OPERAND AGAIN
	ANI	A, $0F		;GET LOW NYBBLE
	ADI	A, $40		;SHIFT TO HEX TEXT
	STAX	[DE+]
	JRE      DEBYTPRINT	;GET LOW BYTE NEXT.....

DECMD5:
	EQI	A, 05		;IS IT EXTRA BYTE TYPE 1?
	JR	DECMD6
	PUSH	HL
	LDAW	[INST1]		;GET OUR INSTRUCTION
	ANI	A, 07		;ISOLATE BOTTOM 3 BITS
	ADI	A, $D0		;ADD OUR "POINTER"
	MOV	L, A
	MVI	H, $7F		;ADD OUR "POINTER"
	LDAX	[HL]
	ADI	A, $80		;SHIFT UP...
	STAX	[DE+]
	POP	HL
	JRE	DECMEND
;;EXBYT1		EQU $7FD0	;EXTRA BYTE TABLE 1 (VABCDEHL)
;;EXBYT2		EQU $7FDC	;EXTRA BYTE TABLE 2 (B D H D+...)
DECMD6:
	EQI	A, 06		;IS IT EXTRA BYTE TYPE 2?
	JR	DECMD7
	LDAW	[INST1]		;GET OUR INSTRUCTION
	ANI	A, 07		;ISOLATE BOTTOM 3 BITS
	EQI	A, 00             ;IF IT'S ZERO, JUMP OUT OF THE ROUTINE
	JR	CM6CONT
	POP	HL		;DISCARD RETURN ADDRESS!
	JRE	ILLEGAL		;
CM6CONT:
	CLC
	RAL	               ;MULT. BY 2
	ADI	A, $DC		;ADD OUR "POINTER"
	MOV	L, A
	MVI	H, $7F		;HIGH BYTE OF POINTER
	LDAX	[HL+]
	ADI	A, $80		;SHIFT UP...
	STAX	[DE+]
	LDAX	[HL+]
	ADI	A, $80		;SHIFT UP...
	STAX	[DE+]
	JR	DECMEND
;	EQI	A, 02		;IS IT ?
;	JR	DECMD2
;DECMD2
DECMD7:
	EQI	A, 07		;IS IT EXTRA BYTE TYPE 3?
	JR	DECMD8
	LDAW	[INST1]		;GET OUR INSTRUCTION
	ANI	A, $0F		;ISOLATE BOTTOM 4 BITS
 	CLC
	RAL	               ;MULT. BY 2
	ADI	A, $EC		;ADD OUR "POINTER"
	PUSH	HL
	MOV	L, A
	MVI	H, $7F		;HIGH BYTE OF POINTER
	LDAX	[HL+]
	ADI	A, $80		;SHIFT UP...
	STAX	[DE+]
	LDAX	[HL+]
	ADI	A, $80		;SHIFT UP...
	STAX	[DE+]
	POP	HL
	JR	DECMEND

;EXBYT3		EQU $7FEC	;EXTRA BYTE TABLE 3 (PA, PB, MK...)

DECMD8:
DECMEND:
	RET
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
























;==============================================
SINE_TBL:
   DB   2,  2,  2,  3,  3,  3,  2,  2
   DB   2,  1,  1,  0,  0,  0,  1,  1
;==============================================
MARIO_MUSIC:		;A SHORT MARIO DITTY
	DB $0B, $07, $00, $06 ;BAH BAH BAH
       	DB $0B, $09, $00, $10
	DB $0B, $09, $00, $11
	DB $07, $08, $00, $04 ;BUM
	DB $0B, $10, $00, $07 ;BAAH
	DB $0E, $10, $00, $24 ;BAAAAAA..
	DB $02, $1D, $00, $00 ;DUMM
	DB $FF

EX7068B:	DB "M", "O", "V", " "	;INSTRUCTION FOR 706x AND 707x
MUS_OFF:                 ;MUSICAL NOTE DATA FOR SILENCE
   DB	0, 1, $FF	;TURNS OFF MUSIC!


TXT_CURS1:	DB $82	;">"-$20
TXT_SPC1:	DB 00
TXT_N1:		DB "*"+$80, "M"+$80, "E"+$80, "M"+$80, "."+$80, "E"+$80
		DB "D"+$80, "I"+$80, "T"+$80, "O"+$80, "R"+$80, "*"+$80
TXT_N2:          DB "*"+$80, "P"+$80, "R"+$80, "G"+$80, "."+$80, "E"+$80
		DB "D"+$80, "I"+$80, "T"+$80, "O"+$80, "R"+$80, "*"+$80
TXT_N3:          DB "*"+$80, "M"+$80, "U"+$80, "S"+$80, "."+$80, "P"+$80
		DB "L"+$80, "A"+$80, "Y"+$80, "E"+$80, "R"+$80, "*"+$80

TXT_B1:		DB "S"+$80, "T"+$80, "A"+$80, ":"+$80, "V"+$80, "I"+$80
		DB "E"+$80, "W"+$80, " "+$80, "G"+$80, "F"+$80, "X"+$80, "."+$80
TXT_B2:          DB "S"+$80, "T"+$80, "A"+$80, ":"+$80, "R"+$80, "U"+$80, "N"+$80
		DB "@"+$80, "C"+$80, "U"+$80, "R"+$80, "S"+$80, "."+$80
TXT_B3:		DB "S"+$80, "T"+$80, ":"+$80, "P"+$80, "L"+$80, "A"+$80
		DB "Y"+$80, "@"+$80, "C"+$80, "U"+$80, "R"+$80, "S"+$80, "."+$80

TXT_MENU:
      DB	"*"-$20, "M"-$20, "A"-$20, "I"-$20, "N"-$20, " "-$20
      DB	"M"-$20, "E"-$20, "N"-$20, "U"-$20, "*"-$20, " "-$20
TXT_01:
      DB	"1"+$10, "."+$80, "E"+$80, "D"+$80, "."+$80, " "+$80, "M"+$80, "E"+$80, "M"+$80, "O"+$80, "R"+$80, "Y"+$80
      DB	"2"+$10, "."+$80, "E"+$80, "X"+$80, "E"+$80, "C"+$80, "."+$80, " "+$80, "C"+$80, "O"+$80, "D"+$80, "E"+$80
      DB	"3"+$10, "."+$80, "P"+$80, "L"+$80, "A"+$80, "Y"+$80, " "+$80, "M"+$80, "U"+$80, "S"+$80, "I"+$80, "C"+$80
      DB	"4"+$10, "."+$80, "S"+$80, "L"+$80, "I"+$80, "D"+$80, "E"+$80, "S"+$80, "H"+$80, "O"+$80, "W"+$80, " "+$80
      DB	"5"+$10, "."+$80, "G"+$80, "A"+$80, "M"+$80, "E"+$80, " "+$80, " "+$80, " "+$80, " "+$80, " "+$80, " "+$80
      DB	"6"+$10, "."+$80, "M"+$80, "I"+$80, "N"+$80, "I"+$80, "-"+$80, "G"+$80, "R"+$80, "A"+$80, "P"+$80, "H"+$80
      DB	"7"+$10, "."+$80, "S"+$80, "C"+$80, "R"+$80, "O"+$80, "L"+$80, "L"+$80, "E"+$80, "R"+$80, " "+$80, " "+$80
      DB	"8"+$10, "."+$80, "I"+$80, "N"+$80, "T"+$80, "R"+$80, "O"+$80, " "+$80, " "+$80, " "+$80, " "+$80, " "+$80
;      DB	"9"+16, "."-32, "5"+9, "5"+9, "5"+9, "5"+9, "5"+9, "5"+9, "5"+9, "5"+9, "5"+9, "5"+9

PRGRES_TEXT:	;THE TEXT FOR OUR PROGRAM RESULT
	DB "A"+$80, " "+$80, "B"+$80, " "+$80, "C"+$80, " "+$80
	DB "D"+$80, " "+$80, "E"+$80, " "+$80, "H"+$80, " "+$80, "L"+$80, " "+$80
;A B C D E H L
;aabbccddeehhll

      NOP
      NOP
      NOP
      NOP
      NOP
      NOP
      NOP
      NOP
      NOP
      NOP
DEADBEEF:
      DB	$DE, $AD, $BE, $EF

#addr $5500
MYTXT1:
    #d $incbin("pokedemo/scroll.txt"), $FF

#addr $5A40
MYPIC4:
    ;4TH (*RLE*) INTERLACED PICTURE OF MAD BALL
    #d $incbin("pokedemo/madball.bin")

#fn pad(bin, size) => bin @ 0`(size - $sizeof(bin))
#addr $5E00
CALTBL:
    ;CALT NAME TABLE
    #d pad("ChkCart", 64)
    #d pad("WritLCD", 64)
    #d pad("PlaySnd", 64)
    #d pad("PlayMus", 64)
    #d pad("ReadJoy", 64)
    #d pad("Clear A", 64)
    #d pad("ClS2RAM", 64)
    #d pad("ClScRAM", 64)
    #d pad("ClC4B0+", 64)
    #d pad("ClC594+", 64)
    #d pad("Cl(H)xB", 64)
    #d pad("HL+=DE", 64)
    #d pad("HL+-Byt", 64)
    #d pad("HL+=E", 64)
    #d pad("Sc<>Sc2", 64)
    #d pad("Sc2<-Sc", 64)
    #d pad("Sc<-Sc2", 64)
    #d pad("@ 01CD", 64)
    #d pad("@ 0B37", 64)
    #d pad("H<-AxE", 64)
    #d pad("HL<->DE", 64)
    #d pad("H+>D+xB", 64)
    #d pad("H->D-xB", 64)
    #d pad("H<->DxB", 64)
    #d pad("StDotBC", 64)
    #d pad("DrwLine", 64)
    #d pad("PrtByte", 64)
    #d pad("PrtText", 64)
    #d pad("@ 0B0E", 64)
    #d pad("ScPosBC", 64)
    #d pad("@ 0C24", 64)
    #d pad("A->H+xB", 64)
    #d pad("RLR x4", 64)
    #d pad("A=(D-H)", 64)
    #d pad("@ 0063", 64)
    #d pad("@ 006D", 64)
    #d pad("+- Word", 64)
    #d pad("@ 0F42", 64)
    #d pad("InvrtSc", 64)
    #d pad("InvtSc2", 64)
    #d pad("@ 0E6E", 64)
    #d pad("@ 0E98", 64)
    #d pad("@ 0EA4", 64)
    #d pad("@ 0ED2", 64)
    #d pad("@ 0FD9", 64)
    #d pad("ClDotBC", 64)
    #d pad("@ 4012", 64)
    #d pad("@ 4015", 64)
    #d pad("@ 4018", 64)
    #d pad("@ 401B", 64)
    #d pad("@ 401E", 64)
    #d pad("@ 4021", 64)
    #d pad("@ 4024", 64)
    #d pad("@ 4027", 64)
    #d pad("@ 402A", 64)
    #d pad("@ 402D", 64)
    #d pad("xx", 64)
    #d pad("xx", 64)
    #d pad("xx", 64)
    #d pad("xx", 64)
    #d pad("xx", 64)
    #d pad("xx", 64)
    #d pad("xx", 64)
    #d pad("xx", 64)

#addr $6000
MYMUSIC:
    #d $06, $12, $06, $09, $0b, $2d, $0b, $09, $0d, $24, $0e, $09, $10, $09, $0e, $36
    #d $06, $1b, $06, $12, $06, $09, $0b, $2d, $0d, $09, $0e, $12, $0b, $09, $0e, $09
    #d $0b, $09, $12, $09, $10, $36, $ff, $ff, $0b, $09, $06, $09, $0b, $09, $0f, $24
    #d $0b, $12, $0f, $09, $0b, $09, $0f, $09, $12, $24, $0f, $12, $12, $09, $0f, $09
    #d $12, $09, $16, $24, $0a, $12, $0a, $12, $0a, $09, $0f, $36, $ff, $ff, $ff, $ff
    #d $0a, $04, $00, $03, $04, $03, $00, $03, $02, $03, $00, $02, $01, $05, $ff, $ff
    #d $04, $01, $03, $01, $01, $01, $00, $00, $ff, $ff, $ff, $ff, $14, $02, $00, $01
    #d $14, $03, $00, $01, $ff, $ff, $ff, $ff, $01, $05, $00, $03, $03, $05, $00, $03
    #d $05, $05, $00, $03, $06, $06, $00, $03, $08, $07, $00, $03, $ff, $ff, $ff, $ff
    #d $12, $05, $13, $04, $14, $03, $15, $02, $13, $04, $11, $05, $10, $06, $ff, $ff
    #d $12, $00, $0f, $00, $16, $00, $ff, $ff, $06, $04, $05, $03, $06, $04, $07, $03
    #d $08, $04, $09, $03, $08, $04, $07, $03, $06, $04, $05, $03, $ff, $ff, $ff, $ff
    #d $02, $01, $01, $01, $00, $01, $ff, $ff, $12, $02, $16, $01, $00, $01, $12, $02
    #d $16, $01, $00, $01, $12, $02, $16, $01, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
    #d $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
    #d $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff

#addr $6120
MYFONT:
    #d $incbin("pokedemo/font.1bpp")[720*8 - 1:71*8]

#addr $63A9
MYGFX2:
    ;THIS IS NOW *RUN-LENGTH ENCODED*!!!!
    #d $incbin("pokedemo/mygfx2.bin")

#addr $6570
OPTB64:
    ;OP TABLE FOR 64xx
    #d pad($f0, 64)
    #d pad($52`8 @ "ANI ", 64)
    #d pad($52`8 @ "XRI ", 64)
    #d pad($52`8 @ "ORI ", 64)
    #d pad($52`8 @ "ADINC ", 64)
    #d pad($52`8 @ "GTI ", 64)
    #d pad($52`8 @ "SUINB ", 64)
    #d pad($52`8 @ "LTI ", 64)
    #d pad($52`8 @ "ADI ", 64)
    #d pad($52`8 @ "ONI ", 64)
    #d pad($52`8 @ "ACI ", 64)
    #d pad($52`8 @ "OFFI ", 64)
    #d pad($52`8 @ "SUI ", 64)
    #d pad($52`8 @ "NEI ", 64)
    #d pad($52`8 @ "SBI ", 64)
    #d pad($52`8 @ "EQI ", 64)

#addr $65F0
OPTB70:
    ;UPPER OPCODE TABLE FOR 70xx
    #d pad($f0, 64)
    #d pad($60`8 @ "ANAX ", 64)
    #d pad($60`8 @ "XRAX ", 64)
    #d pad($60`8 @ "ORAX ", 64)
    #d pad($60`8 @ "ADDNCX ", 64)
    #d pad($60`8 @ "GTAX ", 64)
    #d pad($60`8 @ "SUBNBX ", 64)
    #d pad($60`8 @ "LTAX ", 64)
    #d pad($60`8 @ "ADDX ", 64)
    #d pad($60`8 @ "ONAX ", 64)
    #d pad($60`8 @ "ADCX ", 64)
    #d pad($60`8 @ "OFFAX ", 64)
    #d pad($60`8 @ "SUBX ", 64)
    #d pad($60`8 @ "NEAX ", 64)
    #d pad($60`8 @ "SBBX ", 64)
    #d pad($60`8 @ "EQAX ", 64)

#addr $6670
OPTB48:
    ;OPCODE TABLE FOR 48xx
    #d pad($00`8 @ "PUSH V", 64)
    #d pad($00`8 @ "POP V", 64)
    #d pad($00`8 @ "SKNITFO", 64)
    #d pad($00`8 @ "SKNITFT", 64)
    #d pad($00`8 @ "SKNITF1", 64)
    #d pad($00`8 @ "SKNITF2", 64)
    #d pad($00`8 @ "SKNITFS", 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "SKN CY", 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "SKN Z", 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "PUSH B", 64)
    #d pad($00`8 @ "POP B", 64)
    #d pad($00`8 @ "EI", 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "DI", 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "CLC", 64)
    #d pad($00`8 @ "STC", 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "PEX", 64)
    #d pad($00`8 @ "PUSH D", 64)
    #d pad($00`8 @ "POP D", 64)
    #d pad($00`8 @ "RLL A", 64)
    #d pad($00`8 @ "RLR A", 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "RLD A/H", 64)
    #d pad($00`8 @ "RRD A/H", 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "PER", 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "PUSH H", 64)
    #d pad($00`8 @ "POP H", 64)

#addr $6800
OPTBL1:
    ;OPCODE TABLE 1
    #d pad($00`8 @ "NOP", 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "INX SP ", 64)
    #d pad($00`8 @ "DCX SP ", 64)
    #d pad($40`8 @ "LXI SP,", 64)
    #d pad($22`8 @ "ANIW ", 64)
    #d pad($f0, 64)
    #d pad($20`8 @ "ANI A,", 64)
    #d pad($00`8 @ "RET", 64)
    #d pad($00`8 @ "SIO", 64)
    #d pad($00`8 @ "MOV A,B", 64)
    #d pad($00`8 @ "MOV A,C", 64)
    #d pad($00`8 @ "MOV A,D", 64)
    #d pad($00`8 @ "MOV A,E", 64)
    #d pad($00`8 @ "MOV A,H", 64)
    #d pad($00`8 @ "MOV A,L", 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "INX B", 64)
    #d pad($00`8 @ "DCX\0B", 64)
    #d pad($40`8 @ "LXI B,", 64)
    #d pad($22`8 @ "ORIW ", 64)
    #d pad($20`8 @ "XRI A,", 64)
    #d pad($20`8 @ "ORI A,", 64)
    #d pad($00`8 @ "RETS", 64)
    #d pad($00`8 @ "STM", 64)
    #d pad($00`8 @ "MOV B,A", 64)
    #d pad($00`8 @ "MOV C,A", 64)
    #d pad($00`8 @ "MOV D,A", 64)
    #d pad($00`8 @ "MOV E,A", 64)
    #d pad($00`8 @ "MOV H,A", 64)
    #d pad($00`8 @ "MOV L,A", 64)
    #d pad($20`8 @ "INRW ", 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "INX D", 64)
    #d pad($00`8 @ "DCX D", 64)
    #d pad($40`8 @ "LXI D,", 64)
    #d pad($22`8 @ "GTIW ", 64)
    #d pad($02`8 @ "ADINC A", 64)
    #d pad($20`8 @ "GTI A,", 64)
    #d pad($20`8 @ "LDAW ", 64)
    #d pad($00`8 @ "LDAX B", 64)
    #d pad($00`8 @ "LDAX D", 64)
    #d pad($00`8 @ "LDAX H", 64)
    #d pad($00`8 @ "LDAX D+", 64)
    #d pad($00`8 @ "LDAX H+", 64)
    #d pad($00`8 @ "LDAX D-", 64)
    #d pad($00`8 @ "LDAX H-", 64)
    #d pad($20`8 @ "DCRW ", 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "INX H", 64)
    #d pad($00`8 @ "DCX H", 64)
    #d pad($40`8 @ "LXI H,", 64)
    #d pad($22`8 @ "LTIW ", 64)
    #d pad($02`8 @ "SUINB A", 64)
    #d pad($20`8 @ "LTI A,", 64)
    #d pad($20`8 @ "STAW ", 64)
    #d pad($00`8 @ "STAX B", 64)
    #d pad($00`8 @ "STAX D", 64)
    #d pad($00`8 @ "STAX H", 64)
    #d pad($00`8 @ "STAX D+", 64)
    #d pad($00`8 @ "STAX H+", 64)
    #d pad($00`8 @ "STAX D-", 64)
    #d pad($00`8 @ "STAX H-", 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "INR A", 64)
    #d pad($00`8 @ "INR B", 64)
    #d pad($00`8 @ "INR C", 64)
    #d pad($40`8 @ "CALL ", 64)
    #d pad($22`8 @ "ONIW ", 64)
    #d pad($20`8 @ "ADI A,", 64)
    #d pad($20`8 @ "ONI A,", 64)
    #d pad($90`8 @ "48 xx", 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($a0`8 @ "4C xx", 64)
    #d pad($b0`8 @ "4D xx", 64)
    #d pad($70`8 @ "JRE+", 64)
    #d pad($80`8 @ "JRE-", 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "DCR A", 64)
    #d pad($00`8 @ "DCR B", 64)
    #d pad($00`8 @ "DCR C", 64)
    #d pad($40`8 @ "JMP ", 64)
    #d pad($22`8 @ "OFFIW ", 64)
    #d pad($20`8 @ "ACI A,", 64)
    #d pad($20`8 @ "OFFI A,", 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($c0`8 @ "60 xx", 64)
    #d pad($00`8 @ "DAA", 64)
    #d pad($00`8 @ "RETI", 64)
    #d pad($f0, 64)
    #d pad($d0`8 @ "64 xx", 64)
    #d pad($22`8 @ "NEIW ", 64)
    #d pad($20`8 @ "SUI A,", 64)
    #d pad($20`8 @ "NEI A,", 64)
    #d pad($f0, 64)
    #d pad($20`8 @ "MVI A,", 64)
    #d pad($20`8 @ "MVI B,", 64)
    #d pad($20`8 @ "MVI C,", 64)
    #d pad($20`8 @ "MVI D,", 64)
    #d pad($20`8 @ "MVI E,", 64)
    #d pad($20`8 @ "MVI H,", 64)
    #d pad($20`8 @ "MVI L,", 64)
    #d pad($e0`8 @ "70 xx", 64)
    #d pad($f0, 64)
    #d pad($f0, 64)
    #d pad($00`8 @ "JB", 64)
    #d pad($f0, 64)
    #d pad($22`8 @ "EQIW ", 64)
    #d pad($20`8 @ "SBI A,", 64)
    #d pad($20`8 @ "EQI A,", 64)

#addr $6C00
MARSPR:
    ;3 MARIO SPRITE DEFINITIONS
    #d $incbin("pokedemo/marspr.1bpp")[511:416]
    #d $incbin("pokedemo/marspr.1bpp")[383:288], (-1)`64
    #d $incbin("pokedemo/marspr.1bpp")[255:160]
    #d $incbin("pokedemo/marspr.1bpp")[127:32], (-1)`64

#addr $6C40
OPT70E:
    ;OPCODE TABLE FOR 70:0E, 0F, 1E, 1F, 2E, 2F, 3E, 3F
    #d pad($40`8 @ "SSPD ", 64)
    #d pad($40`8 @ "LSPD ", 64)
    #d pad($40`8 @ "SBCD ", 64)
    #d pad($40`8 @ "LBCD ", 64)
    #d pad($40`8 @ "SDED ", 64)
    #d pad($40`8 @ "LDED ", 64)
    #d pad($40`8 @ "SHLD ", 64)
    #d pad($40`8 @ "LHLD ", 64)
    #d $0c6cf6ffbe3e367e6d6c740c00c0e030785818b090d00000ffffffffffffffff
    #d $0c746c6d7e363ebefff66c0c0000d090b018587830e0c000ffffffffffffffff
    #d $00001c3ffeeef6feb518000000c0e030785818b090d00000ffffffffffffffff
    #d $000018b5fef6eefe3f1c00000000d090b018587830e0c000ffffffffffffffff
    #d pad($f0, 64)
    #d pad($51`8 @ "ANA ", 64)
    #d pad($51`8 @ "XRA ", 64)
    #d pad($51`8 @ "ORA ", 64)
    #d pad($51`8 @ "ADDNC ", 64)
    #d pad($51`8 @ "GTA ", 64)
    #d pad($51`8 @ "SUBNB ", 64)
    #d pad($51`8 @ "LTA ", 64)
    #d pad($51`8 @ "ADD ", 64)
    #d pad($f0, 64)
    #d pad($51`8 @ "ADC ", 64)
    #d pad($f0, 64)
    #d pad($51`8 @ "SUB ", 64)
    #d pad($51`8 @ "NEA ", 64)
    #d pad($51`8 @ "SBB ", 64)
    #d pad($51`8 @ "EQA ", 64)

#addr $6D00
OPTB60:
    ;OPCODE TABLE FOR 60xx

#addr $6DA0
MARLEV:
    ;2 SCREENS (*RLE*) FOR THE MARIO "GAME"
    #d $incbin("pokedemo/marlev.bin")

#addr $7000
MYPIC1:
    ;1ST (*RLE*) INTERLACED PICTURE OF ASTRONAUT
    #d $incbin("pokedemo/mypic1.bin")

#addr $7290
NOTTXT:
    ;96 BYTES (+1) FOR THE "NOTEPAD" ROUTINE.
    #d $incbin("pokedemo/nottxt.bin")

#addr $7300
MYPIC2:
    ;2ND (*RLE*) INTERLACED PICTURE OF DRACULA
    #d $incbin("pokedemo/mypic2.bin")

#addr $7750
MYPIC3:
    ;3ND (*RLE*) INTERLACED PICTURE OF A RODENT
    #d $incbin("pokedemo/mypic3.bin")

#addr $7B37
MARPC1:
    ;LAST (*RLE*) INTERLACED PICTURE OF "EPOCH LAND"
    #d $incbin("pokedemo/marpc1.bin")

#addr $7FD0
EXBYT1:
    ; Extra byte table 1 (VABCDEHL)
    #d "VABCDEHL"
    #d 0`48

EXBYT2:
    ; Extra byte table 2 (B D H D+...)
    #d "B D H D+H+D-H-"

EXBYT3:
    ; Extra byte table 3 (PA, PB, MK...)
    #d "PAPBPC"
    #d "MKMBMC"
    #d "T0T1S TM"
